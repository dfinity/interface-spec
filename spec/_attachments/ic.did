type canister_id = principal;
type wasm_module = blob;

type canister_settings = record {
	controllers : opt vec principal;
	compute_allocation : opt nat;
	memory_allocation : opt nat;
	freezing_threshold : opt nat;
};

type definite_canister_settings = record {
	controllers : vec principal;
	compute_allocation : nat;
	memory_allocation : nat;
	freezing_threshold : nat;
};

type change_origin = variant {
	from_user : record {
		user_id : principal;
	};
	from_canister : record {
		canister_id : principal;
		canister_version : opt nat64;
	};
};

type change_details = variant {
	creation : record {
		controllers : vec principal;
	};
	code_uninstall;
	code_deployment : record {
		mode : variant { install; reinstall; upgrade };
		module_hash : blob;
	};
	controllers_change : record {
		controllers : vec principal;
	};
};

type change = record {
	timestamp_nanos : nat64;
	canister_version : nat64;
	origin : change_origin;
	details : change_details;
};

type http_header = record { name : text; value : text };

type http_response = record {
	status : nat;
	headers : vec http_header;
	body : blob;
};

type ecdsa_curve = variant { secp256k1 };

type satoshi = nat64;

type bitcoin_network = variant {
	mainnet;
	testnet;
};

type bitcoin_address = text;

type block_hash = blob;

type outpoint = record {
	txid : blob;
	vout : nat32;
};

type utxo = record {
	outpoint : outpoint;
	value : satoshi;
	height : nat32;
};

type get_utxos_request = record {
	address : bitcoin_address;
	network : bitcoin_network;
	filter : opt variant {
		min_confirmations : nat32;
		page : blob;
	};
};

type get_current_fee_percentiles_request = record {
	network : bitcoin_network;
};

type get_utxos_response = record {
	utxos : vec utxo;
	tip_block_hash : block_hash;
	tip_height : nat32;
	next_page : opt blob;
};

type get_balance_request = record {
	address : bitcoin_address;
	network : bitcoin_network;
	min_confirmations : opt nat32;
};

type send_transaction_request = record {
	transaction : blob;
	network : bitcoin_network;
};

type millisatoshi_per_byte = nat64;

type create_canister_request = record {
	settings : opt canister_settings;
	sender_canister_version : opt nat64;
};

type create_canister_response = record { canister_id : canister_id }

type update_settings_request = record {
	canister_id : principal;
	settings : canister_settings;
	sender_canister_version : opt nat64;
};

type install_code_request = record {
	mode : variant { install; reinstall; upgrade };
	canister_id : canister_id;
	wasm_module : wasm_module;
	arg : blob;
	sender_canister_version : opt nat64;
};

type uninstall_code_request = record {
	canister_id : canister_id;
	sender_canister_version : opt nat64;
};

type start_canister_request = record { canister_id : canister_id }

type stop_canister_request = record { canister_id : canister_id }

type canister_status_request = record { canister_id : canister_id }

type canister_status_response = record {
	status : variant { running; stopping; stopped };
	settings : definite_canister_settings;
	module_hash : opt blob;
	memory_size : nat;
	cycles : nat;
	idle_cycles_burned_per_day : nat;
};

type canister_info_request = record {
	canister_id : canister_id;
	num_requested_changes : opt nat64;
};

type canister_info_response = record {
	total_num_changes : nat64;
	recent_changes : vec change;
	module_hash : opt blob;
	controllers : vec principal;
};

type delete_canister_request = record { canister_id : canister_id }

type deposit_cycles_request = record { canister_id : canister_id }

service ic : {
	create_canister : (create_canister_request) -> (create_canister_response);
	update_settings : (update_settings_request) -> ();
	install_code : (install_code_request) -> ();
	uninstall_code : (uninstall_code_request) -> ();
	start_canister : (start_canister_request) -> ();
	stop_canister : (stop_canister_request) -> ();
	canister_status : (canister_status_request) -> (canister_status_response);
	canister_info : (canister_info_request) -> (canister_info_response);
	delete_canister : (delete_canister_request) -> ();
	deposit_cycles : (deposit_cycles_request) -> ();
	raw_rand : () -> (blob);
	http_request : (
		record {
			url : text;
			max_response_bytes : opt nat64;
			method : variant { get; head; post };
			headers : vec http_header;
			body : opt blob;
			transform : opt record {
				function : func(record { response : http_response; context : blob }) -> (http_response) query;
				context : blob;
			};
		}
	) -> (http_response);

	// Threshold ECDSA signature
	ecdsa_public_key : (
		record {
			canister_id : opt canister_id;
			derivation_path : vec blob;
			key_id : record { curve : ecdsa_curve; name : text };
		}
	) -> (record { public_key : blob; chain_code : blob });
	sign_with_ecdsa : (
		record {
			message_hash : blob;
			derivation_path : vec blob;
			key_id : record { curve : ecdsa_curve; name : text };
		}
	) -> (record { signature : blob });

	// bitcoin interface
	bitcoin_get_balance : (get_balance_request) -> (satoshi);
	bitcoin_get_utxos : (get_utxos_request) -> (get_utxos_response);
	bitcoin_send_transaction : (send_transaction_request) -> ();
	bitcoin_get_current_fee_percentiles : (get_current_fee_percentiles_request) -> (vec millisatoshi_per_byte);

	// provisional interfaces for the pre-ledger world
	provisional_create_canister_with_cycles : (
		record {
			amount : opt nat;
			settings : opt canister_settings;
			specified_id : opt canister_id;
			sender_canister_version : opt nat64;
		}
	) -> (record { canister_id : canister_id });
	provisional_top_up_canister : (record { canister_id : canister_id; amount : nat }) -> ();
};
