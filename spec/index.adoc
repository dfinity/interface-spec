= Public specification of the Internet Computer
Joachim Breitner <joachim@dfinity.org>
0.12.1
:toc2:
:toclevels: 3
:stem: latexmath
:icons: font

== Preamble

This document describes the public interface of the Internet Computer. It is the authoritative source for interface details (request and function names, parameters, encodings). The goal is to have a document that is authoritative, and provides a place and a language to discuss public features of the Internet Computer in a hopefully concrete way. It could also be a document that we can publish to users of the Internet Computer.

Because of its focus on the externally visible behavior of the Internet Computer, it will also help uncover abstraction leaks. Because it aims to describe the full behavior, it helps to show which designs are unexpectedly complicated or don’t go well together. But as it intentionally does not address _how_ to implement this behaviour, it cannot be used as an implementation spec.

=== Status

The `master` version of this document, which claims version number `∞`, corresponds to a collection of finished and approved designs, but typically reflect neither the current status nor target of implementation.

The released versions, which can be found at https://docs.dfinity.systems/public/v/, are targetted by the production implementations (e.g. `replica`, `dfx`). Implementations do not necessarily target the latest released version; chosing an implementation target is a deliberate step coordinated between the involved parties.

See the https://github.com/dfinity-lab/ic-ref/blob/master/README.md[README file of the repository] for more information on versioning and release process.

Please skim the https://github.com/dfinity-lab/ic-ref/pulls?q=is%3Apr+is%3Aopen+%22Public+Spec%22+in%3Atitle[list of open PRs] against this document, to get an overview of ongoing discussions.

=== Process

This document is maintained by its editors (currently Joachim, Jens, Björn). The editors drive its evolution, make sure the right process is followed and try to keep tabs on relevant design discussions happening. Nevertheless, everyone is invited to contribute.

A proposed change of this document should take the form of a Pull Request on GitHub, be titled “Public Spec: _title_”, and its description should answer the following questions:

 1. Which parties (Replica, Languages, SDK, Research) are affected by this change, and why?
 2. Is this a a breaking change or not (important for versioning)
 3. If design slides are required: Which design slides is this based on, and – if not immediate – why do these slides imply the present change. This may initially refer to not-yet-approved slides, if the slides and the interface of a feature are developed side-by-side.

Changes will be merged into `master` when the design is finished. The editors will apply common sense to determine if all stakeholders have been heared and the design is complete.

Generally, PRs should be merged using “squash merge”.

Draft PRs can be used for experimentation and exploration without any process requirement.

== Introduction

Welcome to the Internet Computer! We speak of “the” Internet Computer, because although under the hood, a large number of physical computers are working together in non-trivial ways, in the end we have the appearance of a single, shared, secure and world-wide accessible computer. Much, if not all, of the advanced and complex machinery is hidden from those that use the Internet Computer to run their applications and those who use these applications.

=== Scope of this document

This documents describes this external view of the Internet Computer:
Which interfaces it provides to application developers and users, and what will happen when you use these interfaces.

WARNING: While this document describes the public interface and behavior of the Internet Computer, it is not the primary end-user documentation. The creators of the Internet Computer provide further tools, such as the Motoko programming language, the IDL tooling and the SDK tools, to make programming and using the Internet Computer even more convenient.

If you think of the Internet Computer as a distributed execution engine that _provides_ a WebAssembly-based application hosting service, then this document describes exclusively the latter aspect of it. So to the extent possible, this document will _not_ talk about blockchain, consensus protocols, nodes, subnets and orthogonal persistence.

This document tries to be implementation agnostic: If we decide to re-do the implementation of the Internet Computer from scratch at some point in the future, then this document would (ideally) still be valid as is.

This implies that this document does not speak of the interface of the Internet Computer towards its engineers and administrators, as topics like node update, monitoring, logging are inherently tied to the actual _implementation_ and its architecture.

=== Overview of the Internet Computer

If you want to use the Internet Computer as an application developer, you first create a _canister module_ that contains the WebAssembly code and configuration for your application, and deploy it using the <<http-interface,public HTTP interface>>. You can create canisters using the Motoko language and the SDK, which is more convenient. If you want to use your own tooling, however, then this document describes <<canister-module-format,how a canister module looks like>> and how the <<system-api,WebAssembly code can interact with the system>>.

Once your application is running on the Internet Computer, it is a _canister_, and users can interact with it. They can use the <<http-interface,public HTTP interface>> to interact with the canister according to the <<system-api,System API>>.

The user can also use the HTTP interface to issue read-only queries, which are faster, but cannot change the state of a canister.

.A typical use of the Internet Computer. (This is a simplified view; some of the arrows represent multiple interaction steps or polling.)
[plantuml]
....
actor Developer
actor User
participant "Internet Computer" as IC
participant "Canister 1" as Can1
Developer -> IC : /submit create canister
create Can1
IC -> Can1 : create
Developer <-- IC : canister-id=1
Developer -> IC : /submit install module
IC -> Can1 : initialize
|||
User -> IC : /submit call “hello”
IC -> Can1 : hello
return "Hello world!"
User <-- IC : "Hello World!"
....

Sections “<<http-interface>>” and “<<system-api>>” describe these interfaces, together with a brief description of what they do. Afterwards, you will find a <<public-spec,more formal description>> of the Internet Computer that describes its abstract behavior with high precision.


=== Nomenclature

To get some consistency in this document, we try to use the following terms with precision:

We avoid the term “client”, as it could be the client of the Internet Computer or the client inside the distributed network that makes up the Internet Computer. Instead, we use the term _user_ to the external entity interacting with the internet computer, even if in most cases it will be some code acting on behalf of a (human) user.

The public entry points of canisters are called _methods_. Methods can be declared to be either _update methods_ (state mutation is preserved) or _query methods_ (state mutation is discarded, no further calls can be made).

Methods can be _called_, from _caller_ to _callee_, and will eventually incur a _response_ which is either a _reply_ or a _reject_. A method may have _parameters_, which are provided with concrete _arguments_ in a method call.

Inter-canister calls do not distinguish between update and query methods. Note that calls from a canister to itself also count as "inter-canister". External calls can be update calls, which can call both kinds of methods, and query calls, which can _only_ call query methods.

Internally, a call or a response is transmitted as a _message_ from a _sender_ to a _receiver_. Messages do not have a response.

[[define-wasm-fn]]WebAssembly  _functions_ are exported by the WebAssembly module or provided by the System API. These are _invoked_ and can either _trap_ or _return_, possibly with a return value. Functions, too, have parameters and take arguments.

External _users_ interact with the system by issuing _requests_ on the HTTPS interface. Requests have responses which can either be replies or rejects. Some requests cause internal messages to be created.

Canisters, users, etc. are identified by a _principal_, sometimes also called an _id_.

== Principals

Principals, like canister ids and user ids, are – as far as most uses of the system are concerned – binary blobs.

There is, however, some structure to them to encode specific authentication and authorization behavior.

Principals can have any length between 0 and 29 bytes.

[#id-classes]
=== Special forms of IDs

In this section, `H` denotes SHA-224, `·` denotes blob concatenation and `|p|` denotes the length of `p` in bytes, encoded as a single byte.

There are several classes of ids:

1. _Opaque ids_.
+
These are always generated by the system and have no structure of interest outside the system.
+
NOTE: Typically, these end with the byte `0x01`, but users of the IC should not need to care about that.

2. _Self-authenticating ids_.
+
These have the form `H(public_key) · 0x02` (29 bytes).
+
An external user can use these ids as the `sender` of a request if they own the corresponding private key.  See for example <<authentication>>.
+
NOTE: In the future the system may gain the ability to change the authentication rules for self-authenticating ids, e.g. revoke the original key and configure another one.

3. _Derived ids_
+
These have the form `H(|registering_principal| · registering_principal · derivation_nonce) · 0x03` (29 bytes).
+
These ids are treated specially when an id needs to be registered. In such a request, whoever requests an id can provide a `derivation_nonce`. By hashing that together with the principal of the caller, every principal has a space of ids that only they can register ids from.
+
NOTE: Derived IDs are currently not explicitly used in the public interface of the system, but they may be used internally or in the future.

4. _Anonymous id_
+
This has the form `0x04`, and is used for the anonymous caller. It can be used in call and query requests without a signature.

When the system creates a _fresh_ id, it never creates a self-authenticating id, an anonymous id or an id derived from what could be a canister or user.


[#textual-ids]
=== Textual representation of principals

NOTE: This textual representation does not actually show up in the interface (which always deals with blobs), so it is merely a recommended convention.

We specify a _canonical textual format_ that is recommended whenever principals need to be printed or read in textual format, e.g. in log messages, transactions browser, command line tools, source code.

The textual representation of a blob `b` is `Grouped(Base32(CRC32(b) · b))` where

 * `CRC32` is a four byte check sequence, calculated as defined by ISO 3309, ITU-T V.42 and https://www.w3.org/TR/2003/REC-PNG-20031110/#5CRC-algorithm[elsewhere]
 * `Base32` is the Base32 encoding as defined in https://tools.ietf.org/html/rfc4648#section-6[RFC 4648], with no padding character added.
 * The middle dot denotes concatenation.
 * `Grouped` takes an ASCII string and inserts the separator `-` (dash) every 5 characters. The last group may contain less than 5 characters. A separator never appears at the beginning or end.

The textual representation is conventionally printed with _lower case letters_, but parsed case-insensitively.

Because the maximum size of a principal is 29 bytes, the textual representation will be no longer than 63 characters (10 times 5 plus 3 characters with 10 separators in between them).

[TIP]
=====
The canister with id `0xABCD01` has check sequence `0x233FF206` (https://crccalc.com/?crc=ABCD01&method=crc32&datatype=hex&outtype=hex[online calculator]); the final id is thus `em77e-bvlzu-aq`.

Example command line calculation:
....
( echo ABCD01 | xxd -r -p | crc32 /dev/stdin; echo -n ABCD01 ) |
  xxd -r -p | base32 |
  tr A-Z a-z | tr -d = |
  fold -w5 | paste -sd'-' -
....
=====

[#http-interface]
== HTTPS Interface

The concrete mechanism that users use to send requests to the Internet Computer is via an HTTPS API, which exposes two endpoints to handle the requests, plus one for diagnostics.

[#async-requests]
=== Asynchronous requests

Certain interactions change the state of the Internet Computer. By the very nature of a distributed implementation, they cannot be acted upon immediately, but only with a delay. Moreover, the actual node that the user talks to may not be honest or, for other reasons, may fail to get the request on the way. This implies the following high-level workflow:

1. A user submits a request via the <<http-interface>>. No useful information is returned from the node (as it would not be trustworthy anyways).
2. For a certain amount of time, the system behaves as if it does not know about the request. (Although as part of the HTTP interface the receiving endpoint gives an untrusted acknowledgment of receipt or an untrusted declination of the request.)
3. At some point, the system may accept the request for processing and set its status to `received`.  This indicates that the system as a whole has received the request and plans on processing it (although it may still not get processed if the system is under high load).  Further, the user should also be able to ask any endpoint (for the canister) about the status of the pending request.
4. Once it is clear that the request will be acted upon (sufficient resources, request not yet expired), the status changes to `processing`. Now the user has the guarantee that the request will have an effect (e.g. in the case of a canister call, that it will reach the canister).
5. Now the system is processing the request. For some requests this may be atomic, for others this involves multiple internal steps.
6. Eventually, a response will be produced, and can be retrieved for a certain amount of time. The response is either a `reply`, indicating success, or a `reject`, indicating some form of error.
7. In the case that the response has been retained for long enough, but the request has not expired yet, the system can forget the response data and only remember the request as `done`, to prevent a replay.
8. Once the expiry time is past, the system can prune the request and its response, and completely forget about it.


This yields the following interaction diagram:

[plantuml]
....
(*) --> "User creates request" #DDDDDD
   --> "Submitted to node\n(with 202 response)" as submit #DDDDDD
   --> "received"
   --> "processing"
if "" as X then
  --> "replied"
  --> "done"
  else
  --> "rejected (canister)"
  --> "done"

  "X"        --> "rejected (system)"
  "received" --> "rejected (system)"
             --> "done"

  "received" --> "pruned" #DDDDDD
  "submit" --> "dropped" #DDDDDD
  "done" --> "pruned" #DDDDDD

endif
....

State transitions may be instantaneous and not always externally visible. For example, the system may move from `Received` via `Processing` to `Replied` in one go. Similarly, the system may not implement the `Done` state at all, and keep requests in the previous state until they are dropped.

All gray states are _not_ explicitly represented in the system state, and are indistinguishable from “request does not exist”.

The crucial property of the `Received` state is that the request has made it past the (potentionally malicious) endpoint _into to the system_. It is now pointless (but harmless) to submit the (identical) request again. Before reaching that state, submitting the identical request to further nodes might be a useful safeguard against a malicious or misbehaving node.

The crucial property of the `Processing` state is _the initial effect of the request has or will happen_. This is best explained by an example: Consider a counter canister. It exports a method `inc` that increases the counter. Assume that the canister is bug free, and is not going to be forcibly removed. A user submits a request to call `inc`. If the user sees request status `Processing`, the state change is guaranteed to happen, and the user can stop monitoring the status and does not have to retry submitting.

A request may be rejected by the system or the canister. In either case, there is no guarantee about how much processing of the request has happened.

To avoid replay attacks, the transition from `done` or `received` to `pruned` must happen no earlier than the request’s `ingress_expiry` field.

Requests must stay in `Replied` or `Rejected` long enough for polling clients to catch the response.

When asking the system about the state or response of a request, the user uses a request id (see <<api-request-id>>).

=== Synchronous requests

Other interactions do not change the state of the system, but only _read_ from it. These may either be untrustworthy, in the sense that a malicious node can make up stuff (e.g. query calls to canisters), or certified, in the sense that the node can prove to the user that this is indeed the system's view of things (e.g. reading request statuses, reading account balances). All these reads go through the `read` endpoint.

We use the term _request_ both for the asynchronous requests that passed to `submit`, as well as for the parameters of a _read_, so that common operations like signing can be done in the same way.


[#api-endpoints]
=== Request Endpoints

NOTE: This document does not yet explain how to find the location and port of a running Internet Computer Node, nor how to find out which node(s) to talk to for a given canister.

The following API endpoints are provided:
....
/api/v1/submit
/api/v1/read
....

NOTE: Should we add features that _change the state_ but are node-specific (e.g., “restart”), then these would go through a new endpoint like `/api/v1/command`.

For these endpoints, the user performs a POST request over HTTPS with `Content-type: application/cbor`. The body is an CBOR value containing the request object.

* The `/api/v1/submit` endpoint accepts the _asynchronous_ requests. Upon successful submission, a (code 202) HTTP response without a body is returned; the user can use separate `request_status` requests (see <<api-request-status>>) to determine the response.
* The `/api/v1/read` endpoint accepts the _synchronous_ requests. It returns a response (a CBOR value) as the body of the (code 200) HTTP response.

In both cases, the usual HTTP errors (e.g. 503) may occur. In particular, if the server can determine already that the request is invalid (e.g. too large, wrong or missing fields, invalid signatures) and has no chance to reach the `received` state, it can respond with a suitable 4xx code (e.g. 413 if the request is too large).

NOTE: For some types of synchronous requests (but not all), the node will be able to _prove_ that the overall system agrees on the particular value (e.g. fetching the response from an update call). For which reads, and how this can happen, still needs to be specified.


[#field-types]
=== Field types

The requests supported by the system are expressed as records, i.e. fields with names and values. The fields are typed and can have one of these types:

* `nat`: A (possibly unbounded) natural number
* `text`: Human readable text (e.g. sequence of Unicode codepoints)
* `blob`: Arbitrary binary data

For readability, we use the following type synonyms:
....
type Principal = blob
type CanisterId = Principal
type UserId = Principal
....

NOTE: Of course, user ids and canister ids are _not_ just arbitrary binary blobs, but have structure. Some of that structure is documented in <<id-classes>>. But since that structure is meant to be extensible without breaking existing code (especially running canisters), the interfaces are phrased in terms of arbitrary blobs.

All requests coming in via the HTTP interface need to be _authenticated_ using a cryptographic signature. To that end, the following fields are added to these requests:

The following fields are common among all requests:

* `request_type` (`text`): Indicates the type of request, and is one of the values specified in <<request-types>>.
* The fields `nonce` and `ingress_expiry`, as specified in <<authentication>>.

[#authentication]
=== Authentication

All requests coming in via the HTTP interface need to be _authenticated_ using a cryptographic signature. To that end, the following fields is added to these requests:

* `nonce` (`blob`, optional): Arbitrary user-provided data, typically randomly generated. This can be used to create distinct requests with otherwise identical fields.
* `ingress_expiry` (`nat`, required): An upper limit on the validity of the request, expressed in nanoseconds since 1970-01-01 (like <<system-api-time,ic0.time()>>). This avoids replay attacks: The system will not accept requests, or transition requests from status `received` to status `processing`, if their expiry date is in the past. The system may refuse to accept requests with an ingress expiry date too far in the future.

Furthermore, the request records are wrapped in a envelope record with these fields:

* `content` (`record`): the actual request content
* `sender_pubkey` (`blob`, optional): Public key used to authenticate this request. Since a user may have more than one key, this field tells the system which key is used.
* `sender_sig` (`blob`, optional): Signature to authenticate this request.

For requests that have a `sender` field, the public key must authenticate the `sender` principal. For the `request_status` request, the public key must authenticate the sender of the original request.

A public key can authenticate a principal if the latter is a self-authenticating id derived from that public key (see <<id-classes>>).

The fields `sender_pubkey` and `sender_sig` must be omitted if and only if the `sender` field is the anonymous principal.

The `request_id` (see <<api-request-id>>) is calculated from the content record. This allows the signature to be based on the `request_id`, and implies that signature and public key are not semantically relevant.

The signature scheme used to authenticate users is https://ed25519.cr.yp.to/index.html[*Ed25519*]. In particular:

 * Request fields that indicate public key (`sender_pubkey`, `public_key`) are binary blobs of size 32.
 * Request fields that indicate signatures (`sender_sig`) are binary blobs of size 64.

The `sender_sig` is calculated by signing the concatenation of the 11 bytes `"\x0Aic-request"` (the domain separator) and the 32 byte <<api-request-id, _request id_>> with the secret key that belongs to the public key specified in `public_key`.

[#request-types]
=== Request types

The following subsections list all supported requests and specify

* the classification (synchronous vs. asynchronous)
* the request type string
* the required and optional fields of the request record
* the required and optional field of the reply object (see <<api-request-status>>)
* and a description of their pupose and behavior.

[#api-update]
==== Canister update call

The maybe most important request type is calling an exported method of a canister.

Synchronicity:: asynchronous
Request type:: `call`
Request fields::
* `sender` (`Principal`): The user who issued the request.
* `canister_id` (`CanisterId`): The id of the canister to call.
* `method_name` (`text`): Name of the canister method to call
* `arg` (`blob`): Argument to pass to the canister method
Reply fields::
* `arg` (`blob`): The blob representing the data replied by the canister.

This request type can _also_ be used to call a query method. A user may choose to go this way, instead of via the likely faster and cheaper <<api-query>> below, if they want to get a _certified_ response.

NOTE: The system functionality exposed via the <<ic-management-canister>> can be used this way.

[#api-request-status]
==== Request status

Synchronicity:: synchronous
Request type:: `request_status`
Request fields::
* `request_id` (`blob`): The request id to check the status for, see <<api-request-id>>.
Response fields::
* `status` (`text`): one of `unknown`, `received`, `processing`, `replied`, `rejected` or `done`, see <<async-requests>> for more details on what each status means.
* `reply`: If the status is `replied`, then this member contains the request-type specific reply object. See the specification for the individual request types for which fields exist. If no field are especified (currently not specified), this field contains the empty record.
* `reject_code` (`nat`): If the status is `rejected`, then this member contains the reject code (see <<reject-codes>>).
* `reject_message` (`text`): If the status is `rejected`, then this member contains a textual diagnostic message.
* `time` (`nat`): indicates how fresh this response it. This is _not_ the time of the latest state change, but the time of the certification (to be specified) of this response.

WARNING: Immediately after submitting a request, this may fail (e.g. return with `unknown`) even though the system is in the process of receiving the request.

NOTE: Request responses will not be kept around indefinitely, and eventually the status will revert to `unknown`, as described in <<async-requests>>.

[#api-query]
==== Canister query call

Canister methods that do not change the canister state can be executed more efficiently. This method provides that ability, and returns the canister’s response directly within the HTTP response.

Synchronicity:: synchronous
Request type:: `query`
Request fields::
* `sender` (`Principal`): The user who issued the request.
* `canister_id` (`CanisterId`): The id of the canister to query.
* `method_name` (`text`): Name of the canister query method to call
* `arg` (`blob`): Argument to pass to the canister method
Response fields::
* `status` (`text`): One of `replied` or `rejected`
* `reply`: If the status is `replied`, then this member contains the call reply, just as specified in <<api-update>>.
* `reject_code` (`nat`): If the status is `rejected`, then this member contains the reject code (see <<reject-codes>>).
* `reject_message` (`text`): If the status is `rejected`, then this member contains a textual diagnostic message.

[#api-request-id]
=== Request ids

When querying the status of a request (see <<api-request-status>>), the user identifies the request using a _request id_, which is an object hash of the request's `content`, calculated using using the following stesp. The hash operation is always SHA-256.

1. Treat the request type as the value of a text field named `request_type`.
2. For each field that is present in the request (i.e. omitted optional fields are indeed omitted):
   * hash the fields name (in ascii-encoding, without terminal `\x00`) and the value (with the encoding specified below).
3. Sort these by the hash of the field name.
4. Concatenate these hashes, and hash the result.

The resulting hash of 256bits (32 bytes) is the request id.

NOTE: The request id is independent of the representation of the request (JSON, CBOR, something else), and does not change if the specification adds further optional field to a request type.

NOTE: The recommended textual representation of a request id is a hexadecimal string with capital letters prefixed with '0x'.
E.g., request id consisting of bytes `[00, 01, 02, 03, 04, 05, 06, 07, 08, 09, 0A, 0B, 0C, 0D, 0E, 0F, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 1A, 1B, 1C, 1D, 1E, 1F]` should be displayed as `0x000102030405060708090A0B0C0D0E0F101112131415161718191A1B1C1D1E1F`.

The following encodings of field values as blobs are used

* Binary blobs (`canister_id`, `arg`, `nonce`, `module`) are used as-is.
* String fields (`request_type`, `method_name`) are encoded in UTF-8, without a terminal `\x00`.
* Nat fields (`compute_allocation`, `memory_allocation`, `ingress_expiry`) are encoded using https://en.wikipedia.org/wiki/LEB128#Unsigned_LEB128[Unsigned LEB128] encoding.
  For example, `0` should be encoded as a single zero byte `[0x00]` and `624485` should be encoded as byte sequence `[0xE5, 0x8E, 0x26]`.

[TIP]
====
Example calculation (where `H` denotes SHA-256 and `·` denotes blob concatenation):

[source,,options="nowrap"]
----
request_id_of({ request_type: "call", canister_id: 0x00000000000004D2, method_name: "hello", arg: "DIDL\x00\xFD*"})
 = H(concat (sort
   [ H("request_type") · H("call")
   , H("canister_id") · H("\x00\x00\x00\x00\x00\x00\x04\xD2")
   , H("method_name") · H("hello")
   , H("arg") · H("DIDL\x00\xFD*")
   ]))
 = H(concat (sort
   [ 769e6f87bdda39c859642b74ce9763cdd37cb1cd672733e8c54efaa33ab78af9 · 7edb360f06acaef2cc80dba16cf563f199d347db4443da04da0c8173e3f9e4ed
   , 0a3eb2ba16702a387e6321066dd952db7a31f9b5cc92981e0a92dd56802d3df9 · 4d8c47c3c1c837964011441882d745f7e92d10a40cef0520447c63029eafe396
   , 293536232cf9231c86002f4ee293176a0179c002daa9fc24be9bb51acdd642b6 · 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
   , b25f03dedd69be07f356a06fe35c1b0ddc0de77dcd9066c4be0c6bbde14b23ff · 6c0b2ae49718f6995c02ac5700c9c789d7b7862a0d53e6d40a73f1fcd2f70189
   ]))
 = H(concat
   [ 0a3eb2ba16702a387e6321066dd952db7a31f9b5cc92981e0a92dd56802d3df9 · 4d8c47c3c1c837964011441882d745f7e92d10a40cef0520447c63029eafe396
   , 293536232cf9231c86002f4ee293176a0179c002daa9fc24be9bb51acdd642b6 · 2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824
   , 769e6f87bdda39c859642b74ce9763cdd37cb1cd672733e8c54efaa33ab78af9 · 7edb360f06acaef2cc80dba16cf563f199d347db4443da04da0c8173e3f9e4ed
   , b25f03dedd69be07f356a06fe35c1b0ddc0de77dcd9066c4be0c6bbde14b23ff · 6c0b2ae49718f6995c02ac5700c9c789d7b7862a0d53e6d40a73f1fcd2f70189
   ])
 = 8781291c347db32a9d8c10eb62b710fce5a93be676474c42babc74c51858f94b
----
====

[#reject-codes]
=== Reject codes

An API request or inter-canister call that is pending in the system will eventually result in either a _reply_ (indicating success, and carrying data) or a _reject_ (indicating an error of some sorts). A reject contains a _rejection code_ that classifies the error and a hopefully helpful _reject message_ string.

Rejection codes are member of the following enumeration:

* `SYS_FATAL` (1):  Fatal system error, retry unlikely to be useful.
* `SYS_TRANSIENT` (2): Transient system error, retry might be possible.
* `DESTINATION_INVALID` (3): Invalid destination (e.g. canister/account does not exist)
* `CANISTER_REJECT` (4): Explicit reject by the canister.
* [[CANISTER_ERROR]]`CANISTER_ERROR` (5): Canister error (e.g., trap, no response)

The symbolic names of this enumeration are used throughout this specification, but on all interfaces (HTTPS API, System API), they are represented as positive numbers as given in the list above.

The error message is guaranteed to be a string, i.e. not arbitrary binary data.

When canisters explicitly reject a message (see <<system-api-requests>>), they can specify the reject message, but _not_ the reject code; it is always `CANISTER_REJECT`. In this sense, the reject code is trustworthy: If the system responds with a `SYS_FATAL` reject, then it really was the system issuing this reject.

[#api-status]
=== Status endpoint

Additionally, the Internet Computer provides an API endpoint to obtain various status fields at
....
/api/v1/status
....

For this endpoint, the user performs a GET request, and receives a CBOR value with the following fields. The Internet Computer may include additional implementation-specific fields.

* `ic_api_version` (string, mandatory): Identifies the interface version supported, i.e. the version of the present document that the internet computer aims to support, e.g. `0.8.1`. The implementation may also return `unversioned` to indicate that it does _not_ comply to a particular version, e.g. in between releases.
* `impl_source` (string, optional): Identifies the implementation of the Internet Computer, by convention with the canonical location of the source code (e.g. `https://github.com/dfinity/dfinity`).
* `impl_version` (string, optional): If the user is talking to a released version of an Internet Computer implementation, this is the version number. For non-released versions, output of `git describe` like `0.1.13-13-g2414721` would also be very suitable.
* `impl_revision` (string, optional): The precise git revision of the Internet Computer implementation

See <<api-cbor>> for details on the precise CBOR encoding of this object.

NOTE: Future additions may include local time, geographic location, and other
useful implementation-specific information such as blockheight. This data may
possibly signed by the node.

[#api-cbor]
=== CBOR encoding of requests and responses

Requests and responses are specified here as records with named fields and using suggestive human readable syntax. The actual format in body of the HTTP request or response, however, is https://en.wikipedia.org/wiki/CBOR[CBOR].

Concretely, it consists of a data item with major type 6 (“Semantic tag”) and tag value `55799` (see https://tools.ietf.org/html/rfc7049#section-2.4.5[Self-Describe CBOR]), followed by a record.

Requests consist of an envelope record with keys `sender_sig` (a blob), `sender_pubkey` (a blob) and `content` (a record). The first two are metadata that are used for request authentication, while the last one is the actual content of the request.

The following encodings are used:

* Strings: Major type 3 (“Text string”).
* Blobs: Major type 2 (“Byte string”).
* Integer numbers: Major type 0 or 1 (“Unsigned/signed integer”) if small enough to fit that type, else the https://tools.ietf.org/html/rfc7049#section-2.4.2[Bignum] format is used.
* Records: Major type 5 (“Map of pairs of data items”), followed by the fields, where keys are encoded with major type 3 (“Text string”).

As advised by https://tools.ietf.org/html/rfc7049#section-3[section “Creating CBOR-Based Protocols”] of the CBOR spec, we clarify that:

* Floating-point numbers may not be used to encode integers.
* Duplicate keys are prohibited in CBOR maps.

[TIP]
====
A typical request would be (written in https://tools.ietf.org/html/rfc7049#section-6[CBOR diagnostic notation], which can be checked and converted on http://cbor.me/[cbor.me]):
....
55799({
  "content": {
    "request_type": "call",
    "canister_id": h'ABCD01',
    "method_name": "say_hello",
    "arg": h'0061736d01000000',
  },
  "sender_sig": h'DEADBEEF',
  "sender_pubkey": h'b7a3c12dc0c8c748ab07525b701122b88bd78f600c76342d27f25e5f92444cde'
})
....

====

[#api-cddl]
=== CDDL description of requests and responses

The https://tools.ietf.org/html/rfc8610[Concise Data Definition Language (CDDL)] is a data description language for CBOR. This section summarizes the format of the CBOR data passed to and from the entry points described above. You can also link:./requests.cddl[download the file].

[source,bash]
----
include::requests.cddl[]
----

=== Ordering guarantees

In order to allow for a distributed implementation of the Internet Computer, the order in which the various messages between canisters are delivered and executed is not fully specified.

The  guarantee we do give is that function calls between two canisters are executed in order, so that a canister that requires in-order execution need not wait for the response from an earlier message to a canister before sending a later message to that same canister.

More precisely:

 * Method calls between any _two_ canisters are delivered in order, as if they
   were communicating over a single simple FIFO queue.
 * If a WebAssembly function, within a single invocation, makes multiple calls
   to the same canister, they are queued in the order of invocations to `ic0.call_perform`.
 * Responses (including replies with `ic0.msg_reply`, explicit rejects with `ic0.msg_reject` and system-generated error responses) do _not_ have any ordering guarantee relative to each other or to method calls.
 * There is no particular order guarantee for ingress messages submitted via
   the HTTP interface.

=== Synchronicity across nodes

This documents describes the Internet Computer as having a single global state that can be modified and queried. In reality, it consists of many nodes, which may not be perfectly in sync.

As long as you talk to one (honest) node only, the observed behavior is nicely sequential. If you issue an update (i.e. state-mutating) call to a canister (e.g. bump a counter), and node A indicates that the call has been executed, and you then issue a query call to node A, then A's response is guaranteed to include the effect of the update call (and you will receive the updated counter value).

If you then (quickly) issue a read request to node B, it may be that B responds to your read query based on the old state of the canister (and you might receive the old counter value).

A related problem is that some reads are not certified, and nodes may be dishonest in their response. In that case, the user might want to get more assurance by querying multiple nodes and comparing the result, which is easier if the all queries run against the same state.

Both problems can be solved if read requests can specify the desired state to query, either at-least-this-state (to solve the first problem) or an exactly-this-future-state (to solve the second). This requires some way of identifying states (abstract state counters, timestamps, block heights).

NOTE: Even without this feature, applications can work around these problems. For the first problem, the query result could be such that the user can tell if the query has been received or not. For the second problem, if replies are monotonic in some sense the user can get assurance in their intersection (e.g. if the query returns a list of events that grows over time, then even if different nodes return different lists, the user can get assurance in those events returned by many nodes).



[#canister-module-format]
== Canister module format

A canister module is simply a https://webassembly.github.io/spec/core/index.html[WebAssembly module] in binary format (typically `.wasm`).

WARNING: This may need refinement for features like multiple modules, shared linked libraries and possibly static assets. In that case we might go for a zip-file-with-metadata approach.

[#system-api]
== Canister interface (System API)

The System API is the interface between the running canister and the Internet Computer. It allows the WebAssembly module of a canister to expose functionality to the users (method entry points) and the system (e.g. initialization), and exposes system functionality to the canister (e.g. calling other canisters). Because WebAssembly is rather low-level, it also explains how to express higher level concepts (e.g. binary blobs).

We want to leverage advanced WebAssembly features, such as WebAssembly host references. But as they are not yet supported by all tools involved, this section describes an initial System API that does not rely on host references. To emphasize that this is just a preliminary interface, we group the system methods under the module name `ic0`, planning to use `ic` for the real deal.
In section <<host-references>>, we outline some of the proposed uses of WebAssembly host references.

[#system-api-module]
=== WebAssembly module requirements

In order for a WebAssembly module to be usable as the code for the canister, it needs to conform to the following requirements:

* If it imports a memory, it must import it from `env.memory`. In the following, “the Wasm memory” refers to this memory.
* If it imports a table, it must import it from `env.table`. In the following, “the Wasm table” refers to this table.
* It may only import a function if it is listed in <<system-api-imports>>.
* It may have a `(start)` function.
* If it exports a function called `canister_init`, the function must have type `+() -> ()+`.
* If it exports any functions called `canister_update <name>` or `canister_query <name>` for some `name`, the functions must have type `+() -> ()+`.
* It may not export both `canister_update <name>` and `canister_query <name>` with the same `name`.
* No floating point instructions are used in the module. (This will be allowed in the future.)
* No floating point local or global variables are used in the module. (This will be allowed in the future.)

=== Interpretation of numbers

WebAssembly number types (`i32`, `i64`) do not indicate if the numbers are to be interpreted as signed or unsigned. Unless noted otherwise, whenever the System API interprets them as numbers (e.g. memory pointers, buffer offsets, array sizes), they are to be interpreted as unsigned.

=== Entry points

The canister provides entry points which are invoked by the system under various circumstances:

* The canister may export a function named `canister_init` and type `+() -> ()+`.
* The canister may export a function named `canister_pre_upgrade` and type `+() -> ()+`.
* The canister may export a function named `canister_post_upgrade` and type `+() -> ()+`.
* The canister may export functions named `canister_update <name>` and type `+() -> ()+`.
* The canister may export functions named `canister_query <name>` and type `+() -> ()+`.
* The canister table may contain functions of type `+(env : i32) -> ()+` which may be used as callbacks for inter-canister calls.

If the execution of any of these entry points traps for any reason, then all changes to the WebAssembly state, as well as the effect of any externally visible system call (like `ic0.msg_reply`, `ic0.msg_reject`, `ic0.call_perform`), are discarded. For upgrades, this transactional behaviour applies to the `canister_pre_upgrade`/`canister_post_upgrade` sequence as a whole.


[#system-api-init]
==== Canister initializaion

If `canister_init` is present, then this is the first exported WebAssembly function invoked by the system. The argument that was passed along with the canister initialization call (see <<ic-install_code>>) is available to the canister via `ic0.msg_arg_data_size/copy`.

The system assumes the canister to be fully instantiated if the `canister_init` method entry point returns.  If the `canister_init` method entry point traps, then canister installation has failed, and the canister is reverted to its previous state (i.e. empty with `install`, or whatever it was for a `reinstall`).

[#system-api-upgrades]
==== Canister upgrades

When a canister is upgraded to a new WebAssembly module, the system:

 1. Invokes `canister_pre_upgrade` (if present) on the old instance, to give the canister a chance to clean up (e.g. move data to <<system-api-stable-memory,stable memory>>).
 2. Instantiates the new module, including the execution of `(start)`, with a fresh WebAssembly state.
 3. Invokes `canister_post_upgrade` (if present) on the new instance.

The stable memory is preserved throughout the process; any other WebAssembly state is discarded.

During these steps, no other entry point of the old or new canister is invoked. The `canister_init` function of the new canister is _not_ invoked.

These steps are atomic: If `canister_pre_upgrade` or `canister_post_upgrade` trap, the upgrade has failed, and the canister is reverted to the previous state. Otherwise, the upgrade has succeeded, and the old instance is discarded.

[#system-api-requests]
==== Public methods

To define a public method of name `name`, a WebAssembly module exports a function with name `canister_update <name>` or `canister_query <name>` and type `+() -> ()+`. We call this the _method entry point_. The name of the exported function distinguishes update and query methods.

NOTE: The space in `canister_update <name>` resp. `canister_query <name>` is intentional. There is exactly one space between `canister_update/canister_query` and the `<name>`.

The argument of the call (e.g. the content of the `arg` field in the <<api-update,API request to call a canister method>>) is copied into the canister on demand using the System functions shown below.

Eventually, a method will want to send a response, using `ic0.reply` or `ic0.reject`

==== Callbacks

Callbacks are addressed by their table index (as a proxy for a Wasm `funcref`).

In the reply callback of a <<system-api-call,inter-canister method call>>, the argument refers to the response to that call. In reject callbacks, no argument is available.


[#system-api-imports]
=== Overview of imports

The following sections describe various system imports, which we summarize here.

....
ic0.msg_arg_data_size : () -> i32;                                          // I U Q Ry
ic0.msg_arg_data_copy : (dst : i32, offset : i32, size : i32) -> ();        // I U Q Ry
ic0.msg_caller_size : () -> (i32);                                          // I G U Q
ic0.msg_caller_copy : (dst : i32, offset: i32, size : i32) -> ();           // I G U Q
ic0.msg_reject_code : () -> i32;                                            // Ry Rt
ic0.msg_reject_msg_size : () -> i32;                                        // Rt
ic0.msg_reject_msg_copy : (dst : i32, offset : i32, size : i32) -> ();      // Rt

ic0.msg_reply_data_append : (src : i32, size : i32) -> ();                  // U Q Ry Rt
ic0.msg_reply : () -> ();                                                   // U Q Ry Rt
ic0.msg_reject : (src : i32, size : i32) -> ();                             // U Q Ry Rt

ic0.msg_funds_available : ( unit_src : i32, unit_size : i32 ) -> i64;       // U Rt Ry
ic0.msg_funds_refunded : ( unit_src : i32, unit_size : i32 ) -> i64;        // Rt Ry
ic0.msg_funds_accept :                                                      // U Rt Ry
  ( unit_src : i32, unit_size : i32, amount : i64 ) -> ();

ic0.canister_self_size : () -> (i32);                                       // *
ic0.canister_self_copy : (dst : i32, offset : i32, size : i32) -> ();       // *
ic0.canister_balance : ( unit_src : i32, unit_size : i32 ) : i64;           // *

ic0.call_new :                                                              // U Ry Rt
  ( callee_src  : i32,
    callee_size : i32,
    name_src : i32,
    name_size : i32,
    reply_fun : i32,
    reply_env : i32,
    reject_fun : i32,
    reject_env : i32,
  ) -> ();
ic0.call_data_append : (src : i32, size : i32) -> ();                       // U Ry Rt
ic0.call_funds_add :                                                        // U Ry Rt
  (unit_src : i32, unit_size : i32,  amount : i64) -> ();
ic0.call_perform : () -> ( err_code : i32 );                                // U Ry Rt

ic0.stable_size : () -> (page_count : i32);                                 // *
ic0.stable_grow : (new_pages : i32) -> (old_page_count : i32);              // *
ic0.stable_write : (offset : i32, src : i32, size : i32) -> ();             // *
ic0.stable_read : (dst : i32, offset : i32, size : i32) -> ();              // *

ic0.time : () -> (timestamp : i64);                                         // *

ic0.debug_print : (src : i32, size : i32) -> ();                            // * s
ic0.trap : (src : i32, size : i32) -> ();                                   // * s
....

The comment after each function lists from where these functions may be invoked:

* `I`: from `canister_init` or `canister_post_upgrade`
* `G`: from `canister_pre_upgrade`
* `U`: from `canister_update …`
* `Q`: from `canister_query …`
* `Ry`: from a reply callback
* `Rt`: from a reject callback
* `s`: the `(start)` module initialization function
* `*` = `I U Q Ry Rt` (NB: Not `(start)`)

If the canister invokes a system import from somewhere else, it will trap.

=== Blob-typed arguments and results

WebAssembly functions parameter and result types can only be primitive number types. To model functions that accept or return blobs or text values, the following idiom is used:

To provide access to a string or blob `foo`, the System API provides two functions:

  ic0.foo_size : () -> (i32)
  ic0.foo_copy : (dst : i32, offset: i32, size : i32) -> ()

The `*_size` function indicates the size, in bytes, of `foo`. The `*_copy` function copies `size` bytes from `foo[offset..offset+size]` to `memory[dst..dst+size]`. This traps if `offset+size` is greater than the size of `foo`, or if `dst+size` exceeds the size of the Wasm memory.


Dually, a System API function that conceptually takes a blob or string as a parameter `foo` has two parameters:

  ic0.set_foo : (src : i32, size: i32) -> …

which copies, at the time of function invocation, the data referred to by `src`/`size` out of the canister. Unless otherwise noted, this traps if `src+size` exceeds the size of the WebAssembly memory.

=== Method arguments

The canister can access an argument. For `canister_init`, `canister_post_upgrade` and method entrypoints, the argument is the argument of the call; in a reply callback, it refers to the received reply. So the lifetime of the argument data is a single WebAssembly function execution, not the whole method call tree.

* {blank}
+
  ic0.msg_arg_data_size : () -> i32
  ic0.msg_arg_data_copy : (dst : i32, offset : i32, size : i32) -> ()
+
The message argument data.

* {blank}
+
  ic0.msg_caller_size : () -> (i32)
  ic0.msg_caller_copy : (dst : i32, offset: i32, size : i32) -> ()
+
The identity of the caller, which may be a canister id or a user id. During canister installation or upgrade, this is the id of of the user or canister requesting the installation or upgrade.

* `+ic0.msg_reject_code : () -> i32+`
+
Returns the reject code, if the current function is invoked as a reject callback.
+
It returns the special “no error” code `0` if the callback is _not_ invoked as a reject callback; this allows canisters to use a single entry point for both the reply and reject callback, if they choose to do so.
+
* {blank}
+
  ic0.msg_reject_msg_size : () -> i32
  ic0.msg_reject_msg_copy : (dst : i32, offset : i32, size : i32) -> ()
+
The reject message. Traps if there there is no reject message (i.e. if `reject_code` is `0`).

[#responding]
=== Responding

Eventually, the canister will want to respond to the original call, either by replying (indicating success) or rejecting (signalling an error):

* `+ic0.msg_reply_data_append : (src : i32, size : i32) -> ()+`
+
Appends idata it to the (initially empty) data reply.
+
NOTE: This can be invoked multiple times to build up the argument with data from various places on the Wasm heap. This way, the canister does not have to first copy all the pieces from various places into one location.
+
This traps if the current call already has been responded to.

* `+ic0.msg_reply : () -> ()+`
+
Replies to the sender with the data assembled using `ic0.msg_reply_data_append`.
+
This function can be called at most once (a second call will trap), and must be called exactly once to indicate success.
+
See <<system-api-funds>> for how this interacts with funds available on this call.

* `+ic0.msg_reject : (src : i32, size : i32) -> ()+`
+
Rejects the call. The data referred to by `src`/`size` is used for the diagnostic message.
+
This system call traps if `src+size` exceeds the size of the WebAssembly memory, or if the current call already has been responded to, or if the data referred to by `src`/`size` is not valid UTF8.
+
The other end will receive this reject with reject code `CANISTER_REJECT`, see <<reject-codes>>.
+
Possible reply data assembled using `ic0.msg_reply_data_append` is discarded.
+
See <<system-api-funds>> for how this interacts with funds available on this call.

[#system-api-canister-self]
=== Self-identification

A canister can learn about its own identity:

* {blank}
+
  ic0.canister_self_size : () -> (i32)
  ic0.canister_self_copy: (dst : i32, offset : i32, size : i32) -> ()
+
These functions allow the canister to query its own canister id (as a blob).


[#system-api-call]
=== Inter-canister method calls

When handling an update call (or a callback), a canister can do further calls to another canister. Calls are assembled in a builder-like fashion, starting with `ic0.call_new`, adding more attributes using the `ic0.call_*` functions, and eventually performing the call with `ic0.call_perform`.

* {blank}
+
--
  ic0.call_new :
    ( callee_src : i32,
      callee_size : i32,
      name_src : i32,
      name_size : i32,
      reply_fun : i32,
      reply_env : i32,
      reject_fun : i32,
      reject_env : i32,
    ) -> ()

Begins assembling a call to the canister specified by `callee_src/_size` at method `name_src/_size`.

The system records two mandatory callback functions, represented by a table entry index `fun` and some additional value `env`. When the response comes back, the table is read at the corresponding index, expected to be a function of type `+(env : i32) -> ()+` and passed the corresponding `env` value.

The reply callback is executed upon successful completion of the method call, which can query the reply using `ic0.msg_arg_data_*`.

The reject callback is executed if the method calls fails asynchronously or the other canister explicitly rejects the call. The reject code and message can be queried using `ic0.msg_reject_code` and `ic0.msg_reject_msg_*`.


Subsequent calls to the following functions set further attributes of that call, until the call is concluded (with `ic0.call_perform`) or discarded (by returning without calling `ic0.call_perform` or by starting a new call with `ic0.call_new`.)
--

* `+ic0.call_data_append : (src : i32, size : i32)+`
+
Appends the specified bytes to the argument of the call. Initially, the argument is empty.
+
This may be called multiple times between `ic0.call_new` and `ic0.call_perform`.


* `+ic0.call_funds_add : (unit_src : i32, unit_size : i32,  amount : i64) -> ()+`
+
This adds funds onto a call. See <<system-api-funds>>.
+
This may be called multiple times between `ic0.call_new` and `ic0.call_perform`.

* `+ic0.call_perform  : () -> ( err_code : i32 )+`
+
This call concludes assembling the call. It queues the call message to the given destination, but does not actually act on it until the current WebAssembly function returns without trapping.
+
If the system returns `0` as the `err_code`, the system was able to enqueue the call. In this case, the call will either be delivered, returned because the destination canister does not exist or returned because of an out of gas condition. This also means that exactly one of the reply or reject callback will be executed.
+
If the system returns a non-zero value, the call cannot (and will not be) performed.
+
After `ic0.call_perform` and before the next call to `ic0.call_new`, all other `ic0.call_*` function calls trap

[#system-api-funds]
=== Funds

Each canister maintains funds of various units. Units are represented as blob. At the moment, the only supported units are Cycles (represented as `"\x00"`) and ICPT (represented as `"\0x01"`). Other units, including canister-defined units, can be added in the future.

Cycles work like other units, but have some additional special purpose rules since computation on the Internet Computer is paid for in cycles.

* `ic0.canister_balance : ( unit_src : i32, unit_size : i32 ) -> (i64)`
+
indicates the current balance of that unit. The number is the balance before the execution of the current message, minus a reserve for the execution of the current message (only if `unit` denotes cycles), minus any funds queued up to send via `ic0.call_simple`, plus any funds accepted via `ic0.msg_funds_accept`.
+
After execution of the message, unused cycles from the reserve may be added to the cycles balance again.

* `ic0.msg_funds_available : ( unit_src i32, unit_size : i32 ) -> (i64)`
+
returns the amount of the specified `unit` that was transferred by the caller of the current call, and is still available in this message.
+
Initially, in the update method entry point, this is the amount that the caller passed to the canister. When funds are accepted (`ic0.msg_funds_accept`), this reports less funds accordingly. When the call is responsed to (reply or reject), all available funds are refunded to the caller, and this will return 0.

* `ic0.msg_funds_accept : ( unit_src i32, unit_size : i32, amount : i64 ) -> ()`
+
This moves funds from the call to the canister balance. It can be called multiple times.
+
This traps if the canister tries to accept more funds than it can according to `ic0.msg_funds_available`.
+
This means it will trap when used after calling `ic0.msg_reply` or `ic0.msg_reject`, unless `amount = 0`.
+
[TIP]
=====
Example: To accept all ICPTs provided, invoke `ic0.msg_funds_accept("\x01", 1, ic0.msg_funds_available("\x01",1))` in the method handler or a callback handler, _before_ calling reply or reject.
=====

* `ic0.call_funds_add : (unit_src : i32, unit_size : i32,  amount : i64) -> ()`
+
This function moves funds from the canister balance onto the call under construction, to be transferred with that call.
+
The funds are deducted from the balance as shown by `ic0.canister_balance` immediately, and moved back if the call cannot be performed (e.g. if `ic0.call_perform` signals an error, or if the canister invokes `ic0.call_new` or returns without callling `ic0.call_perform`).
+
This traps if trying to transfer more funds than are in the current balance of the canister.

* `ic0.msg_funds_refunded : ( unit_src i32, unit_size : i32 ) -> (i64)`
+
this can only be used in a callback handler (reply or reject), and indicates the amount of the specified `unit` that came back with the response as a refund. The refund has already been added to the canister balance automatically.

[#system-api-stable-memory]
=== Stable memory

Canisters have the ability to store and retrieve data from a secondary memory. The purpose of this _stable memory_ is to provide space to store data beyond upgrades.  The interface mirrors roughly the memory-related instructions of WebAssembly, and tries to be forward compatible with exposing this feature as an additional memory.

The stable memory is initially empty.

* {blank}
+
  ic0.stable_size : () -> (page_count : i32)
+
returns the current size of the stable memory in WebAssembly pages. (One WebAssembly page is 64Ki bytes.)

* {blank}
+
  ic0.stable_grow : (new_pages : i32) -> (old_page_count : i32)
+
tries to grow the memory by `new_pages` many pages containing zeroes.

If successful, returns the _previous_ size of the memory (in pages). Otherwise, returns `-1`.

* {blank}
+
  ic0.stable_write : (offset : i32, src : i32, size : i32) -> ()
+
copies the data referred to by `src`/`size` out of the canister and replaces the corresponding segment starting at `offset` in the stable memory.

This system call traps if `src+size` exceeds the size of the WebAssembly memory or `offset+size` exceeds the size of the stable memory.

* {blank}
+
  ic0.stable_read : (dst : i32, offset : i32, size : i32) -> ()
+
copies the data referred to by `offset`/`size` out of the stable memory and replaces the corresponding bytes starting at `dest` in the canister memory.

This system call traps if `dst+size` exceeds the size of the WebAssembly memory or `offset+size` exceeds the size of the stable memory.

[#system-api-time]
=== System time

The canister can query the system for the current time.

`+ic0.time : () -> (i64)+`

The time is given as nanoseconds since 1970-01-01. The system guarantees that

 * the time, as observed by the canister, is monotonically increasing, even across canister upgrades.
 * within an invocation of one entry point, the time is constant.

The system times of different canisters are unrelated, and calls from one canister to another may appear to travel “backwards in time”.

NOTE: While an implementation will likely try to keep the System Time close to the real time, this is not formally part of this specification.

=== Debugging aids

During local development and execution on a local network, the canister needs a way to emit textual trace messages. On the “real” network, these do not do anything.

* `+ic0.debug_print : (src : i32, size : i32) -> ()+`
+
When executing in an environment that supports debugging, this copies out the data specified by `src` and `size`, and logs, prints or stores it in an environment-appropriate way. The copied data may likely be a valid string in UTF8-encoding, but the environment should be prepared to handle binary data (e.g. by printing it in escaped form). The data does typically not include a terminating `\0` or `\n`.
+
Semantically, this function is always a no-op, and never traps, even if the `src+size` exceeds the size of the memory, or if this function is executed from `(start)`. If the environment cannot perform the print, it just skips it.

Similarly, the system allows the canister to effectively trap, but give some indication about why it trapped:

* `+ic0.trap : (src : i32, size : i32) -> ()+`
+
This function always traps.
+
The environment may copy out the data specified by `src` and `size`, and log, print or store it in an environment-appropriate way, or include it in system-generated reject messages where appropriate. The copied data may likely be a valid string in UTF8-encoding, but the environment should be prepared to handle binary data (e.g. by printing it in escaped form or substituting invalid characters).

[#host-references]
=== Outlook: Using Host References

The Internet Computer aims to make the most of the WebAssembly platform, and embraces WebAssembly features. With WebAssembly host references, we can make the platform more secure, the interfaces more abstract and more compositional. The above `ic0` System API does not yet use WebAssembly host references. Once they become available on our platform, a new version of the System API using host references will be available via the `ic` module. The changes will be, at least

1. The introduction of a `api_nonce` reference, which models the capability to use the System API. It is passed as an argument to `canister_init`, `canister_update <name>` etc., and expected as an argument by almost all system function calls. (The debugging aids remain unconstrainted.)
2. The use of references, instead of binary blobs, to address principals (user ids, canister ids), e.g. in `ic0.msg_caller` or in `ic0.call_simple`. Additional functions will be provided to convert between the transparent binary representation of principals and references.
3. Making the builder interface to create calls build calls identified by a reference, rather than having an implicit partial call in the background.

A canister may only use the old _or_ the new interface; the system detects which interface the canister intends to use based on the names and types of its function imports and exports.

[#ic-management-canister]
== The IC management canister

The interfaces above provide the fundamental ability for external users and canisters to contact other canisters. But the Internet Computer provides additional functionality, such as canister and user management. This functionality is exposed to external users and canisters via the _IC management canister_.

NOTE: The _IC management canister_ is just a facade; it does not actually exist as a canister (with isolated state, Wasm code, etc.).

The IC management canister address is `aaaaa-aa` (i.e. the empty blob).

[#ic-candid]
=== Interface overview

The following interface description, in https://github.com/dfinity-lab/motoko/blob/master/design/IDL.md[Candid syntax], describes the available functionality. You can also link:./ic.did[download the file].
----
include::ic.did[]
----

The binary encoding of arguments and results are as per Candid specification.

[#ic-create_canister]
=== IC method `create_canister`

Before deploying a canister, the administrator of the canister first has to register it with the system, to get a canister id (with an empty canister behind it), and then separately install the code.

A canister has an attribute _controller_; initially, the user who has registered the canister is the controller, but this can be changed using <<ic-set_controller,the `set_controller` method>>

Until code is installed, the canister behaves like one with no public methods.

[#ic-install_code]
=== IC method `install_code`

This method installs code into a canister.

Only the _controller_ of the canister can install code.

If `mode = install` or `mode = reinstall`, this will instantiate the canister module and invoke its `canister_init` system method (if present), as explained in Section “<<system-api-init>>”, passing the `arg` to the canister. Upon replacing an existing canister, all state (including the stable memory) is cleared.

If `mode = upgrade`, this will perform an upgrade of an existing canister module as described in <<system-api-upgrades>>.

This is atomic: If the response to this request is a `reject`, then this call had no effect.

The optional field `compute_allocation`, if present, must be a number between 0 and 100, inclusively. It indicates how much compute power should be guaranteed to this canister, expressed as a percentage of the maximum compute power that a single canister can allocate. If absent, it is treated like an allocation of 0. If the system cannot provide the requested allocation, for example because it is oversubscribed, the call will be rejected.

The optional field `memory_allocation`, if present, must be a number between 0 and 2^48 (i.e 256TB), inclusively. It indicates how much memory the canister is allowed to use in total. Any attempt to grow memory usage beyond this allocation will fail. If absent, it is treated like an allocation of 2^33 (i.e. 8GB). If the system cannot provide the requested allocation, for example because it is oversubscribed, the request will be rejected.

NOTE: Some canisters may not be able to make sense of callbacks after upgrades; these should be stopped first, to wait for all outstanding callbacks. It is expected that the canister admin (or admin tooling) does that separately.

[#ic-set_controller]
=== IC method `set_controller`

Initially, the user or canister that created a canister is its _controller_, but control can be yielded to another user or canister.

Only the current controller of the canister can change the controller.

[#ic-canister_status]
=== IC method `canister_status`

Indicates various information about the canister. It contains:
* The status of the canister. It could be one of `Running`, `Stopping` or `Stopped`.
* A hash of the module installed on the canister. This is `null` if no code is installed.
* The controller of the canister.
* The memory size taken by this canister.
* The balances of this canister. It includes Cycles and ICPTs.

Only the current controller of the canister can request its status.

[#ic-stop_canister]
=== IC method `stop_canister`

The controller of a canister may stop a canister (e.g., to prepare for a canister upgrade).

Stopping a canister is not an atomic action. The immediate effect is that the status of the canister is changed to `Stopping` (unless the canister is already stopped).
The system will reject all calls to a stopping canister, indicating that the canister is stopping.
Responses to a stopping canister are processed as usual.
When all outstanding responses have been processed (so there are no open call contexts), the canister status is changed to `Stopped` and the management canister responds to the caller of the `stop_canister` request.

[#ic-start_canister]
=== IC method `start_canister`
A canister may be started by its controller.

If the canister status was 'Stopped' or `Stopping` then the canister status is simply set to `Running`.
In the latter case all `stop_canister` calls which are processing fail (and are rejected).

If the canister was already `Running` then the status stays unchanged.

[#ic-delete_canister]
=== IC method `delete_canister`

This method deletes a canister from the IC.

Only the _controller_ of the canister can delete it and the canister must already be stopped. Deleting a canister cannot be undone and any state stored on the canister is permanently deleted. Once a canister is deleted, its ID cannot be reused.

[#ic-deposit_funds]
=== IC method `deposit_funds`

This method deposits the funds included in this call into the specified canister.

Only the controller of the canister can deposit funds.

This action may have a cost in cycles, which is deducted from the receiving canister after the funds on this call have been deposited. The call fails if the canister balance plus the deposited funds do not cover the cost.


[#ic-raw_rand]
=== IC method `raw_rand`

This method takes no input and returns 32 pseudo-random bytes to the caller. The return value is unknown to any part of the IC at time of the submission of this call. A new return value is generated for each call to this method.

[#public-spec]
== Abstract public behavior

The previous sections describe the interfaces, i.e. outer edges of the Internet Computer, but give only intuitive and vague information about what these interfaces actually do.

The present section aims to address that question with great precision, by describing the _abstract state_ of the whole Internet Computer, and how this state can change in response to API function calls, or spontaneously (modeling asynchronous, distributed or non-deterministic execution).

The design of this abstract specification (e.g. how and where pending messages are stored) are _not_ to be understood to in any way prescribe a concrete implementation or software architecture. The goals here are formal precision and clarity, but not implementability, so this can lead to different ways of phrasing.

=== Notation

We specify the behavior of the system using pseudo-code.

The manipulated values are primitive values (numbers, text, binary blobs), aggregate values (lists, unordered lists a.k.a. bags, partial maps, records with fixed fields, named constructors) and functions.

We use a concatenation operator `·` with various types: to extend sets and maps, or to concatenate lists with lists or lists with elements.

The shape of values is described using a hand-wavy type system.  We use `Foo = Nat` to define type aliases; now `Foo` can be used instead of `Nat`. Often, the right-hand side is a more complex type here, e.g. a record, or multiple possible types separated by a vertical bar (`|`). Partial maps are written as  `Key ↦ Value` and the function type as `Argument -> Result`.

NOTE: All values are immutable! State change is specified by describing the new state, not by changing existing state.

Record fields are accessed using dot-notation (e.g. `S.request_id > 0`). To create a new record from an existing record `R` with some fields changed, the syntax `R where field = new_value` is used. This syntax can also be used to create new records with some deeply nested field changed: `R where some_map[key].field = new_value`.

In the state transitions, upper-case variables (`S`, `C`, `Req_id`) are free variables: The state transition may be followed for any possible value of these variables. `S` always refers to the state of the system before. A state transition often comes with a list of _conditions_, which may restrict the values of these free variables. The _state after_ is usually described using the record update syntax by starting with `S where`.

For example, the condition `S.messages = Older_messages · M · Younger_messages` says that `M` is some message in field `messages` of the record `S`, and that `Younger_messages` and `Older_messages` are the other messages in the system. If the “state after” specifies `S with messages = Older_messages · Younger_messages`, then the message `M` is removed from the state.

=== Abstract state

In this specification, we describe the Internet Computer as a state machine. In particular, there is a single piece of data that describes the complete state of the system, called `S`.

Of course, this is a huge simplification: The real Internet Computer is distributed and has a multi-component architecture, and the state is spread over many different components, some physically separated. But this simplification allows us to have a concise description of the system, and to easily make global decisions (such as, “is there any pending message”), without having to specify the bookkeeping that allows such global decision.

==== Identifiers

Principals (canister ids and user ids) are blobs, but some of them have special form, as explained in <<id-classes>>.
....
type Principal = Blob
....

The function
....
mk_self_authenticating_id : PublicKey -> Principal
mk_self_authenticating_id pk = H(pk) · 0x02
....
calculates self-authenticating ids.

The function
....
mk_derived_id : Principal -> Blob -> Principal
mk_derived_id p nonce = H(|p| · p · nonce) · 0x03
....
calculates derived ids. With `|p|` we denote the length of the principal, in bytes, encoded as a single byte.

The principal of the anonymous user is fixed:
....
anonymous_id : Principal
anonymous_id = 0x04
....

These function domains and fixed values are mutually disjoint.

Method names can be arbitrary pieces of text:
....
MethodName = Text
....

[#abstract-funds]
==== Funds

Canisters can store and transfer funds, which come in various units. One unit, namely cycles, has special semantics in the system, as many actions deduct cycles.

The type of fund units is a blob, and the values for cycles and ICPT are defined:
....
Unit = Blob
cycle_unit : "\x00"
icpt_unit : "\x01"
....

The type of balances or transferred funds is a (total) function from fund units to amounts.
....
Funds = Unit -> Nat
....
Operations like `+`, `-` are overloaded pointwise. In this spec, all subtractions must be well-defined (i.e. not produce negative results). Comparisons like `<` hold if they hold at all units.

The term `no_funds` indicates no funds:
....
no_funds
 = (λ u. 0) : Funds
....

The following shorthands create funds containing funds of one unit:
....
funds_of_unit(unit, amount) = (λ u. if u = unit then amount else 0) : Funds
cycle_funds(n) = funds_of_unit(cycle_unit, n)
....


[#abstract-canisters]
==== Abstract canisters

The <<system-api,WebAssembly System API>> is relatively low-level, and some of its details (e.g. that the argument data is queried using separate calls, and that closures are represented by a function pointer and a number, that method names need to be mangled) would clutter this section. Therefore, we abstract over the WebAssembly details as follows:

* The state of a WebAssembly module (memory, tables, globals) is hidden behind an abstract `WasmState`. The `WasmState` contains the `StableMemory`, which can be extracted using `pre_upgrade` and passed to `post_upgrade`.

* A canister module `CanisterModule` consists of an initial state, and a (pure) function that models function invocation. It either indicates that the canister function traps, or returns a new state together with a description of the invoked asynchronous System API calls.
+
....
WasmState = (abstract)
StableMemory = (abstract)
Callback = (abstract)

type Timestamp = Nat;
Arg = {
  data : Blob
  caller: Principal
  time : Timestamp
}

RejectCode = Nat
Response = Reply Blob | Reject (RejectCode, Text)
MethodCall = {
  callee : CanisterId;
  method_name: MethodName;
  arg: Blob;
  transferred_funds: Funds;
  callback: Callback;
}

UpdateFunc = WasmState -> Trap | Return {
  new_state : WasmState;
  new_calls : List MethodCall;
  response : NoResponse | Response;
  funds_accepted : Funds;
}
QueryFunc = WasmState -> Trap | Return Response

Balance = Funds
AvailableFunds = Funds

CanisterModule = {
  init : (CanisterId, Arg, Balance) -> Trap | Return WasmState
  pre_upgrade : (WasmState, caller : Principal, Timestamp, Balance) -> Trap | Return StableMemory
  post_upgrade : (CanisterId, StableMemory, Arg, Balance) -> Trap | Return WasmState
  update_methods : MethodName ↦ ((Arg, Balance, AvailableFunds) -> UpdateFunc)
  query_methods : MethodName ↦ ((Arg, Balance) -> QueryFunc)
  callbacks : (Callback, Response, Funds, Timestamp, Balance, AvailableFunds) -> UpdateFunc
}
....

This high-level interface presents a pure, mathematical model of a canister, and hides the bookkeeping required to provide the System API as seen in Section <<system-api>>.

The `CanisterId` parameter of `init` and `post_upgrade` is merely passed through to the canister, via the `canister.self` system call.

The parsing of a blob to a canister module is modelled via the predicate
....
parse_wasm_mod : Blob -> CanisterModule -> Bool
....

The concrete mapping of this abstract `CanisterModule` to actual WebAssembly concepts and the System API is described separately in section <<concrete-canisters>>.


==== Call contexts

The Internet Computer provides certain messaging guarantees: If a user or a canister calls another canister, it will eventually get a single response (a reply or a rejection), even if some canister code along the way fails.

To ensure that only one response is generated, and also to detect when no response can be generated any more, the system maintains a _call context_. The `responded` field is set to `true` once the call has received a response. Further attempts to respond will now fail.

....
CallCtxt = {
  canister : CanisterId;
  origin : CallOrigin;
  responded : bool;
  available_funds : Funds;
}
CallId = (abstract)
CallOrigin
  = FromUser {
      request : Request;
    }
  | FromCanister {
      calling_context : CallId;
      callback: Callback
    }
....

==== Calls and Messages

Calls into and within the Internet Computer are implemented as messages passed between canisters. During their lifetime, messages change shape: they begin as a call to a public method, which is resolved to a WebAssembly function that is then executed, potentially generating a response which is then delivered.

Therefore, a message can have different shapes:
....
Queue = Unordered | Queue { from : CanisterId; to : CanisterId }
EntryPoint
  = PublicMethod MethodName Principal Blob
  | Callback Callback Response Funds

Message
  = CallMessage {
      origin : CallOrigin;
      caller : Principal;
      callee : CanisterId;
      method_name : Text;
      data : Blob;
      transferred_funds : Funds;
      queue : Queue;
    }
  | FuncMessage {
      call_context : CallId;
      receiver : CanisterId;
      entry_point : EntryPoint;
      queue : Queue;
    }
  | ResponseMessage {
      origin : CallOrigin;
      response : Response;
      refunded_funds : Funds;
    }
....

The `queue` field is used to describe the message ordering behavior. Its concrete value is only used to determine when the relative order of two messages must be preserved, and is otherwise not interpreted. Response messages are not ordered, as explained above, so they have no `queue` field.

A reference implementation would likely maintain a separate list of `messages` for each such queue to efficiently find eligible messages; this document uses a single global list for a simpler and more concise system state.

==== API requests

We distinguish between the _asynchronous_ API requests passed to `/api/v1/submit`, which may be present in the system state, and the _synchronous_ API requests passed to `/api/v1/read`, which are only ephemeral.

....
Envelope = {
  content : Request | APIReadRequest;
  sender_pubkey : PublicKey | NoPublicKey;
  sender_sig : Signature | NoSignature;
}

Request
  = CanisterUpdateCall = {
    nonce : Blob;
    ingress_expiry : Nat;
    sender : UserId;
    canister_id : CanisterId;
    method_name : Text;
    data : Blob;
  }
....

The evolution of a `Request` goes through these states, as explained in <<async-requests>>:
....
RequestStatus
  = Received
  | Processing
  | Rejected (RejectCode, Text)
  | Completed { result : Value }
  | Done
....

These are the synchronous read messages:
....
APIReadRequest
  = ReadStatus = {
    nonce : Blob;
    ingress_expiry : Nat;
    request_id : Request;
  }
  | CanisterQuery = {
    nonce : Blob;
    ingress_expiry : Nat;
    sender : UserId;
    canister_id : CanisterId;
    method_name : Text;
    data : Blob;
  }
....

A `ReadStatus` refers to a request by way of a _request id_, as specifeid in <<api-request-id>>:
....
Request = Blob
request_id_of : Request -> Request
....


For the signatures in an `Request`, we assume that the following function implements https://ed25519.cr.yp.to/index.html[*Ed25519*].
....
PublicKey = Blob
Signature = Blob
verify_signature : PublicKey -> Signature -> Blob -> Bool
....

==== The system state

Finally, we can describe the state of the Internet Computer as a record having the following fields:

....
S = {
  requests : Request ↦ RequestStatus;
  canisters : CanisterId ↦ CanState;
  controllers : CanisterId ↦ Principal;
  canister_status: CanisterId ↦ CanStatus;
  time : CanisterId ↦ Timestamp;
  balances: CanisterId ↦ Funds;
  system_time : Timestamp
  call_contexts : CallId ↦ CallCtxt;
  messages : List Message; // ordered!
}
CanState
 = EmptyCanister | {
  wasm_state : WasmState;
  module : CanisterModule;
  raw_module : Blob;
}
CanStatus
  = Running
  | Stopping (List (CallOrigin, Funds))
  | Stopped
....

==== Initial state

The initial state of the system is
....
{
  requests = ();
  canisters = ();
  controllers = ();
  time = ();
  balances = ();
  system_time = T;
  call_contexts = ();
  messages = ();
}
....
for some time stamp `T`, using `()` to denote the empty map or bag.

=== State transitions

Based on this abstract notion of the state, we can describe the behavior of the system. There are three classes of behaviors:

 * Asynchronous API requests that are submitted via `/api/v1/read`. These transitions describes checks that the request must pass to be considered received.
 * Spontaneous transitions that model the internal behavior of the system, by describing conditions on the state that allow the transition to happen, and the state after.
 * Responses to reads (i.e. `/api/v1/read`). By definition, these do _not_ change the state of the system, and merely describe the response based on the read request and the current system state.

The state transitions are not complete with regard to error handling. For example, the behavior of sending a request to a non-existent canister is not specified here. For now, we trust implementors to make sensible decisions there.

We model the <<ic-management-canister>> with one state transition per method. There, we assume a function
....
candid : Value -> Blob
....
that represents Candid encoding; this is implicitly taking the method types, as declared in <<ic-candid>>, into account. We model the parsing of Candid values in the  “Conditions” section using `candid` as well, by treating it as a non-deterministic function.

The principal of the management ic canister is the empty blob (i.e. `aaaaa-aa`):
....
ic_principal : principal = ""
....

==== Envelope Authentication

The following predicate describes when an envelope `E` correctly signs the enclosed request with a key belonging to a user `U`:

....
verify_envelope(E, U) =
     is_anonymous_id U && E.sender_pubkey = NoPublicKey && E.sender_sig = NoSignature
  || ∃ PK, SIG.
       is_self_authenticating_id U E.sender_pubkey
       && verify_signature E.sender_pubkey E.sender_sig ("\x0Aic-request" · request_id_of(E.content)) = true
....


==== API Request submission

After a node accepts a request via `/api/v1/submit`, it gets added to the system in the `Received` state.

This may only happen if the signature is valid and is created with a correct key.
Due to this check, the envelope is discarded after this point.

Requests that have expired are dropped here.

Submitted request:: `E : Envelope`
Conditions::
....
    verify_envelope(E, E.content.sender)
    E.content ∉ requests
    S.system_time <= E.content.ingress_expiry
....
State after::
....
S with
    requests[E.content] = Received
....

NOTE: This is not instantaneous (the system takes some time to agree it accepts the request) nor guaranteed (a node could just drop the request, or maybe it did not pass validation). But once it has entered the system like this, it will be acted upon.

==== Request rejection

The system may reject a received message for internal reasons (high load, low resources) or expiry. The precise conditions are not specified here, but the reject code must indicate this to be a system error.

Conditions::
....
    S.requests[R] = Received
    Code = SYS_FATAL or Code = SYS_TRANSIENT
....
State after::
....
S with
    requests[R] = Rejected (Code, Msg)
....

==== Initiating canister calls

A first step in processing a canister update call is to create a `CallMessage` in the message queue.

This is only allowed if the request has not expired.

The `request` field of the `FromUser` origin establishes the connection to the api message. One could use the corresponding `request_id_of` for this purpose, but this formulation is more abstract.

We do not make any guarantees about the order of incoming messages.

Conditions::
....
    S.requests[CanisterUpdateCall R] = Received
    S.system_time <= R.ingress_expiry
    C = S.canisters[R.canister_id]
....
State after::
....
S with
    requests[CanisterUpdateCall R] = Processing
    messages =
      CallMessage {
        origin = FromUser { request = CanisterUpdateCall R };
        caller = R.sender;
        callee = R.canister_id;
        method_name = R.method_name;
        arg = R.arg;
        transferred_funds = no_funds;
        queue = Unordered;
      } · S.messages
....

==== Calls to stopped/stopping canisters are rejected

A call to a canister which is stopping or stopped is automatically rejected.

Conditions::
....
    S.messages = Older_messages · CallMessage CM · Younger_messages
    (CM.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ CM.queue)
    S.canister_status[CM.callee] = Stopped or S.canister_status[CM.callee] = Stopping _
....

State after::
....
    S.messages = Older_messages · Younger_messages  ·
      ResponseMessage {
          origin = S.call_contexts[CM.call_context].origin
          response = Reject (CANISTER_ERROR, "canister stopped");
          refunded_funds = CM.transferred_funds;
      }
....

==== Call context creation

Before invoking a message to a public entry point, some bookkeeping is required:

 * A call context is created, and the method is looked up in the list of exports. This happens for both ingress and inter-canister messages.
The canister must be running (so not stopped, or stopping).

The position of the message in the queue is unchanged.

This only happens for “real” canisters, not the IC management canister.

Conditions::
....
    S.messages = Older_messages · CallMessage CM · Younger_messages
    S.canisters[CM.callee] ≠ EmptyCanister
    S.canister_status[CM.callee] = Running
    Ctxt_id ∉ dom S.call_contexts
....
State after::
....
S with
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id;
        receiver = CM.callee;
        entry_point = PublicMethod CM.method_name CM.caller CM.data
        queue = CM.queue;
      } ·
      Younger_messages
    call_contexts[Ctxt_id] = {
      canister = CM.callee;
      origin = CM.origin;
      responded = false;
      available_funds = CM.funds;
    }
....

We can execute any message that is at the head of its queue, i.e. there is no older message with the same abstract `queue` field.  The actual message execution, if successful, may enqueue further messages and -- if the function returns a response -- record this response.  The new call and response messages are enqueued at the end.

==== Message execution

The transition models the actual execution of a message, whether it is an initial call to a public method or a response. In either case, a call context already exists (see transition “Call context creation”).

Conditions::
....
    S.messages = Older_messages · FuncMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    S.canisters[M.receiver] ≠ EmptyCanister
    Mod = S.canisters[M.receiver].module

    Balance_before = S.balances[M.receiver] - cycle_funds(Max_cycles)
    Available = S.call_contexts[M.call_contexts].available_funds
    ( M.entry_point = PublicMethod Name Caller Data
      Arg = { data = Data; caller = Caller; time = S.time[M.receiver] }
      (F = M.update_methods[M.method_name](Arg, Balance_before, Available))
      or
      (F = as_update(Mod.query_methods[M.method_name], Arg, Balance_before))
    )
    or
    ( M.entry_point = Callback Callback Response Refund
      F = Mod.callbacks(Callback, Response, Refund, S.time[M.receiver], Balance_before, Available)
    )

    R = F(S.canisters[M.receiver].wasm_state)
....
State after::
....
if
  R = Return res
  cycle_funds(Cycles_used) ≤ cycle_funds(Max_cycles)
  res.funds_accepted ≤ Available
  cycle_funds(Cycles_used) + ∑ [ call.transferred_funds | call ∈ res.new_calls ]
     ≤ S.balances[M.receiver] + res.funds_accepted
  (res.response = NoResponse) or (S.call_contexts[M.call_context].responded = false)
then
  S with
    canisters[M.receiver].wasm_state = res.new_state;
    messages =
      Older_messages ·
      Younger_messages ·
      [ CallMessage {
          origin = FromCanister {
            call_context = M.call_context;
            callback = call.callback
          };
          caller = C.callee;
          callee = call.callee;
          method_name = call.method_name;
          arg = call.arg;
          transferred_funds = call.transferred_funds
          queue = Queue { from = M.receiver; to = call.callee };
        }
      | call ∈ res.new_calls ] ·
      [ ResponseMessage {
          origin = S.call_contexts[M.call_context].origin
          response = res.response;
          refunded_funds = AvailableFunds - res.funds_accepted;
        }
      | res.response ≠ NoResponse ]

    if res.response = NoResponse:
       call_contexts[M.call_context].available_funds = AvailableFunds - res.funds_accepted
    else
       call_contexts[M.call_context].responded = true
       call_contexts[M.call_context].available_funds = no_funds

    balances[M.receiver] = S.balances[M.receiver]
      + res.funds_accepted
      - cycle_funds(Cycles_used)
      - ∑ [ call.transferred_funds | call ∈ res.new_calls ]
else
  S with
    messages = Older_messages · Younger_messages
    balances[M.receiver] = S.balances[M.receiver]
      - cycle_funds(Cycles_used)
....

The cycle consumption of executing this message is modeled via the unspecified `Cycles_used` variable. The maximum number of cycles to consume is also unspecified, and expressed as `Max_cycles`.

This transition detects certain behaviour that will appear as a trap (and which an implementation may implement by trapping directly in a system call):

 * Responding if the present call context has already been responded to
 * Accepting more funds than are available on the call context
 * Sending out more funds than available to the canister
 * Consuming more cycles than allowed (and reserved)

If message execution <<define-wasm-fn,_traps_ (in the sense of a Wasm function)>>, the message gets dropped. No response is generated (as some other message may still fulfill this calling context). Any state mutation is discarded.

If message execution <<define-wasm-fn,_returns_ (in the sense of a Wasm function)>>, the state is updated and possible outbound calls and responses are enqueued.

Note that returning does _not_ imply that the call associated with this message now  _succeeds_ in the sense defined in <<responding, section responding>>; that would requre a (unique) call to `ic0.reply`.
Note also that the state changes are persisted even when the system is set to synthesize a <<CANISTER_ERROR,CANISTER_ERROR>> reject immediately afterward (which happens when this returns without calling `ic0.reply` or `ic0.reject`, the corresponding call has not been responded to and there are no outstanding callbacks, see <<starvation>>).

The function `as_update` turns a query function into an update function, this is merely a notational trick to simplify the rule
....
as_update(f, arg, balance) = λ wasm_state →
  match f(arg, balance)(wasm_state) with
    Trap → Trap
    Return res → Return {
      new_state = wasm_state;
      new_calls = [];
      response = res;
      funds_accepted = no_funds;
    }
....
Note that by construction, a query function will either trap or return with a response; it will never send calls, and it will never change the state of the canister.

[#starvation]
==== Call context starvation

If there is no call, downstream calling context or response that could possibly fulfill a calling context, then a reject is synthesized. The error message below is _not_ indicative. In particular, if the system has an idea about _why_ this starved, it can put that in there (e.g. the initial message handler trapped with an out-of-memory access).

Conditions::
....
    S.call_contexts[Ctxt_id].responded = false
    ∀ CallMessage M ∈ S.messages. M.origin.calling_context ≠ Ctxt_id
    ∀ ResponseMessage M ∈ S.messages. M.origin.calling_context ≠ Ctxt_id
    ∀ ctxt_ids.
        S.call_contexts[ctxt_ids].responded = false
        ==> S.call_contexts[ctxt_ids].origin.calling_context ≠ Ctxt_id
....
State after::
....
S with
    call_contexts[Ctxt_id].responded = true
    call_contexts[Ctxt_id].available_funds = no_funds
    messages =
      S.messages ·
      ResponseMessage {
        origin = S.call_contexts[Ctxt_id].origin;
        response = Reject (CANISTER_ERROR, "starvation");
        refunded_funds = S.call_contexts[Ctxt_id].available_funds
      }
....

==== Call context removal

If there is no call, downstream calling context or response that references a call context, and the call context has been replied to, then the call context can be removed.

Conditions::
....
    S.call_contexts[Ctxt_id].responded = true
    ∀ CallMessage M ∈ S.messages. M.origin.calling_context ≠ Ctxt_id
    ∀ ResponseMessage M ∈ S.messages. M.origin.calling_context ≠ Ctxt_id
    ∀ ctxt_ids.
        S.call_contexts[ctxt_ids].responded = false
        ==> S.call_contexts[ctxt_ids].origin.calling_context ≠ Ctxt_id
....
State after::
....
S with
    call_contexts[Ctxt_id] = (deleted)
....


==== IC Management Canister: Canister creation

The system chooses an appropriate canister id and instantiates a new (empty) canister identified by this id. The issuer of the request is set to be the controller of newly created canister. The canister status is set to 'Running'. All funds on this call are now the canister's initial funds.

This is also when the System Time of the new canister starts ticking.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'create_canister'
    M.arg = candid()
    is_system_assigned CanisterId
    CanisterId ∉ dom S.canisters
....
State after::
....
S with
    canisters[CanisterId] = EmptyCanister
    time[CanisterId] = CurrentTime
    controllers[CanisterId] = M.caller
    funds[CanisterId] = M.transferred_funds
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = Accepted (candid({canister_id = CanisterId}))
        refunded_funds = no_funds
      }
    canister_status[CanisterId] = Running
....

This uses the predicate
....
is_system_assigned : Principal -> Bool
....
which characterizes all system-assigned ids.

To avoid clashes with potential user ids or is derived from users or canisters, we require (somewhat handwavy) that

 * `is_system_assigned (mk_self_authenticating_id pk) = false` for possible public keys `pk` and
 * `is_system_assigned (mk_derived_id p dn) = false` for any `p` that could be a user id or canister id.
 * `is_system_assigned p = false` for `|p| > 29`.

==== IC Management Canister: Canister status

The controller of a canister can check for its status (i.e. one of Running, Stopping, or Stopped).

The `Memory_size` is the (in this specification underspecified) total size of storage in bytes.

The order of units in the `balances` field is unspecified.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'canister_status'
    M.arg = candid(A)
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = candid({
          status = S.canister_status[A.canister_id];
	  module_hash =
            if S.canisters[A.canister_id] = EmptyCanister
            then null
            else ?(SHA-265(S.canisters[A.canister_id].raw_module));
          controller = S.controllers[A.canister_id];
          memory_size = Memory_size;
          balances =
            [ (unit, S.balance[A.canister_id](unit))
            | S.balance[A.canister_id](unit) > 0 ];
        })
        refunded_funds = M.transferred_funds
      }
....

==== IC Management Canister: Code installation

Only the controller of the given canister can install code. This transition installs new code over an empty or existing canister. This involves invoking the `canister_init` system method (see <<system-api-init>>), which must succeed and must not invoke other methods.

The `compute_allocation` and `memory_allocation` are ignored in this abstract model of the Internet Computer, as it does not address questions of performance or scheduling.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_princpal
    M.method_name = 'install_code'
    M.arg = candid(A)
    Mod = parse_wasm_mod(A.wasm_module)
      (A.mode = install && S.canisters[A.canister_id] = EmptyCanister)
    or A.mode = reinstall
    M.caller = S.controllers[A.canister_id]
    Arg = {
      data = A.arg;
      caller = M.caller;
      time = S.time[A.canister_id];
    }
    Mod.init(A.canister_id, A.arg) = Return New_state
....
State after::
....
S with
    canisters[A.canister_id] =
      { wasm_state = New_state; module = Mod; raw_module = A.wasm_module }
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = Accepted (candid())
        refunded_funds = M.transferred_funds
      }
....

==== IC Management Canister: Code upgrade

Only the controller of the given canister can install new code. This changes the code of an _existing_ canister, preserving the state in the stable memory. This involves invoking the `canister_pre_upgrade` system method on the old and `canister_post_upgrade` system method on the new canister, which must succeed and must not invoke other methods.

The `compute_allocation` and `memory_allocation` are ignored in this abstract model of the Internet Computer, as it does not address questions of performance or scheduling.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'install_code'
    M.arg = candid(A)
    Mod = parse_wasm_mod(A.wasm_module)

    A.mode = upgrade
    S.canisters[A.canister_id] ≠ EmptyCanister
    M.caller = S.controllers[A.canister_id]
    S.canisters[A.canister_id] = { wasm_state = Old_state; module = Old_module }
    Old_module.pre_upgrade(Old_State, M.caller, S.time[A.canister_id]) = Return Stable_memory
    Arg = {
      data = A.arg;
      caller = M.caller;
      time = S.time[A.canister_id];
    }
    Mod.post_upgrade(A.canister_id, Stable_memory, Arg) = Return New_state
....
State after::
....
S with
    canisters[A.canister_id] =
      { wasm_state = New_state; module = Mod; raw_module = A.wasm_module }
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = Accepted (candid())
        refunded_funds = M.transferred_funds
      }
....

==== IC Management Canister: Setting controllers

Only the controller of the given canister can modify the controller field.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'set_controller'
    M.arg = candid(A)
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    controllers[A.canister_id] = A.new_controller
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = Accepted (candid())
        refunded_funds = M.transferred_funds
      }
....

==== IC Management Canister: Stopping a canister

The controller of a canister can stop a canister. Stopping a canister goes through two steps. First, the status of the canister is set to `Stopping`; as explained above, a stopping canister rejects all incoming requests and continues processing outstanding responses. When a stopping canister has no more open call contexts, its status is changed to `Stopped` and a response is generated. Note that when processing responses, a stopping canister can make calls to other canisters and thus create new call contexts. In addition, a canister which is stopped, or stopping will accept (and respond) to further `stop_canister` requests.

We encode this behavior via three (types of) transitions:

1. First, any `stop_canister` call sets the state of the canister to `Stopping`; we record in the status the origin (and funds) of all `stop_canister` calls which arrive at the canister while it is stopping (or stopped).
2. Next, when the canister has no open call contexts (so, in particular, all outstanding responses to the canister have been processed), the status of the canister is set to `Stopped`.
3. Finally, each pending `stop_canister` call (which are encoded in the status) is responded to, to indicate that that the canister is stopped.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'stop_canister'
    M.arg = candid(A)
    S.canister_status[A.canister_id] = Running
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    messages = Older_messages · Younger_messages
    S.status[A.canister_id] = Stopping [(M.origin, M.transferred_funds)]
....

The next two transition record any additional 'stop_canister' requests that arrive at a stopping (or stopped) canister in its status.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'stop_canister'
    M.arg = candid(A)
    S.canister_status[A.canister_id] = Stopping Origins
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    messages = Older_messages · Younger_messages
    S.status[A.canister_id] = Stopping (Origins · (M.origin, M.transferred_funds))
....


The status of a stopping canister which has no open call contexts is set to `Stopped`, and all pending `stop_canister` calls are replied to.

Conditions::
....
    S.canister_status[A.canister_id] = Stopping Origins
    ∀ Ctxt_id. S.call_contexts[Ctxt_id].canister ≠ A.canister_id
....
State after::
....
    S.canister_status[CanisterId] = Stopped
    S.messages = Messages ·
        [ ResponseMessage {
            origin = O
            response = Accepted (candid())
            refunded_funds = F
          }
	| (O, F) ∈ Origins
	]
....

NOTE: Sending a `stop_canister` message to an already stopped canister is acknowledged (i.e. responded with success), but is otherwise a no-op:

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'stop_canister'
    M.arg = candid(A)
    S.canister_status[A.canister_id] = Stopped
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    messages = Older_messages · Younger_messages
    S.messages = Messages ·
        ResponseMessage {
          origin = M.origin
          response = Accepted (candid())
        }
....

==== IC Management Canister: Starting a canister

The controller of a canister can start a stopped canister. If the canister is already running, the command has no effect on the canister.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'start_canister'
    M.arg = candid(A)
    S.status[A.canister_id] = Running or S.status[A.canister_id] = Stopped
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    S.status[A.canister_id] = Running
    messages = Older_messages · Younger_messages ·
        ResponseMessage{
            origin = M.origin
            response = Accepted (candid())
            refunded_funds = M.transferred_funds
        }
....


If the status of the canister was 'Stopping', then the canister status is set to `Running`. The pending `stop_canister` request(s) are rejected.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'start_canister'
    M.arg = candid(A)
    S.status[A.canister_id] = Stopping Origins
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    S.status[A.canister_id] = Running
    messages = Older_messages · Younger_messages ·
        ResponseMessage{
            origin = M.origin
            response = Accepted (candid())
            refunded_funds = M.transferred_funds
        } ·
        [ ResponseMessage {
            origin = O
            response = Reject (CANISTER_REJECT, 'Canister has been restarted')
            refunded_funds = F
          }
	| (O, F) ∈ Origins
	]
....

==== IC Management Canister: Canister deletion

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'delete_canister'
    M.arg = candid(A)
    S.canister_status[A.canister_id] = Stopped
    M.caller = S.controllers[A.canister_id]
....
State after::
....
S with
    canisters[CanisterId] = (deleted)
    controllers[CanisterId] = (deleted)
    canister_status[CanisterId] = (deleted)
    time[CanisterId] = (deleted)
    balances[CanisterId] = (deleted)
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = Accepted (candid())
        refunded_funds = M.transferred_funds + S.balances[CanisterId]
      }
....

==== IC Management Canister: Depositing funds

The unspecified cost for this operation is modeled as `Cycle_cost`.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'deposit_funds'
    M.arg = candid(A)
    M.caller = S.controllers[A.canister_id]
    cycle_funds(Cycle_cost) ≤ S.balances[A.canister_id] + M.transferred_funds
....
State after::
....
S with
    balances[CanisterId] =
      S.balances[A.canister_id] + M.transferred_funds - Cycle_cost
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = Accepted (candid())
        refunded_funds = no_funds
      }
....


==== IC Management Canister: Random numbers

The management canister can produce pseudo-random bytes. It always returns a 32-byte `blob`:

The precise guarantees around the randomness, e.g. unpredictability, are not captured in this formal semantics.

Conditions::
....
    S.messages = Older_messages · CallMessage M · Younger_messages
    (M.queue = Unordered) or (∀ msg ∈ Older_messages. msg.queue ≠ M.queue)
    M.callee = ic_principal
    M.method_name = 'raw_rand'
    M.arg = candid()
    |B| = 32
....
State after::
....
S with
    controllers[A.canister_id] = A.new_controller
    messages = Older_messages · Younger_messages ·
      ResponseMessage {
        origin = M.origin
        response = Accepted (candid(B))
        refunded_funds = M.transferred_funds
      }
....

==== Callback invocation

When an inter-canister call has been responded to, we can queue the call to the callback.

This “bookkeeping transition” must be immediately followed by the corresponding “Message execution” transition.

Conditions::
....
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    RM.origin = FromCanister {
        call_context = Ctxt_id
        callback = Callback
      }
....
State after::
....
S with
    balances[S.call_contexts[Ctxt_id].canister] += RM.refunded_funds
    messages =
      Older_messages ·
      FuncMessage {
        call_context = Ctxt_id2
        receiver = C
        entry_point = Callback Callback FM.response RM.refunded_funds
        queue = Unordered
      } ·
      Younger_messages
....

==== Respond to user request

When an ingress method call has been responded to, we can record the response in the list of queries.

Conditions::
....
    S.requests[M] = Processing
    S.messages = Older_messages · ResponseMessage RM · Younger_messages
    RM.origin = FromUser { request = M }
....
State after::
....
S with
    messages = Older_messages · Younger_messages
    requests[M] =
      | Completed { result = R } if response = Reply R
      | Rejected R               if response = Reject R
....

NB: The refunded funds, `RM.refunded_funds` are, by construction, empty, with the exception of when the controller of a canister is a user, and deletes a canister with funds. In the current specification, these funds disappear in thin air in that case. This is likely to change in some way or another.

==== Request clean up

The system will keep the data for a completed or rejected request around for a certain, implementation defined amount of time, to allow clients to poll for the data. After that time, the data of the request will be dropped:

Conditions::
....
    (S.requests[M] = Completed _) or (S.requests[M] = Rejected _)
....
State after::
....
S with
    requests[M] = Done
....


At the same or some later point, the request will be removed from memory of the system. This must happen no earlier than the ingress expiry time set in the request.

Conditions::
....
    (S.requests[M] = Completed _) or (S.requests[M] = Rejected _) or (S.requests[M] = Done)
    M.ingress_expiry < S.system_time
....
State after::
....
S with
    requests[M] = (deleted)
....

==== Time progressing

Time progresses. Abstractly, it does so independently for each canister, and in unspecified intervals.

Conditions::
....
    T0 = S.time[CanisterId]
    T1 > T0
....
State after::
....
S with
    time[CanisterId] = T1
....

Similarly, the system time, used to expire requests, progresses:

Conditions::
....
    T0 = S.system_time
    T1 > T0
....
State after::
....
S with
    system_time = T1
....

==== Read: Status

The user can query the status of a request. The type of `result`, given as `Value` in the above spec, can vary depending on the request type.

NOTE: There is a phase where a request was issued by the user, but has not yet been received by the whole system. During this phase, the request status behaves as if the request has never been seen. It may silently be dropped, or eventually be marked as pending.

Submitted request:: `E`
Conditions::
....
  E.content = ReadStatus RS
  request_id_of(R) = RS.request_id
  verify_envelope(E, R.sender)
  S.system_time <= RS.ingress_expiry
  S.requests[R] = Status
....
Read response::
A record with
* `{status: received}` if `Status = Received`
* `{status: processing}` if `Status = Processing`
* `{status: rejected; reject_code: <code>: reject_message: <msg>}` if `Status = Rejected (code, msg)`
* `{status: replied; result : <result>}` if `Status = Completed { result = result }`
* `{status: done}` if `Status = Done`


==== Read: query call

Canister query calls can be executed directly.  They can only be executed against canisters which are `Running`.

Submitted request:: `E`
Conditions::
....
  E.content = CanisterQuery Q
  verify_envelope(E, Q.sender)
  S.system_time <= Q.ingress_expiry
  S.canisters[Q.canister_id] ≠ EmptyCanister
  S.canister_status[Q.canister_id] = Running
  C = S.canisters[Q.canister_id]
  Balance = S.balances[Q.canister_id]
  F = C.module.query_methods[Q.method_name]
  Arg = {
    data = Q.arg;
    caller = Q.sender;
    time = S.time[Q.callee];
  }
....
Read response::
* If `F(Arg, Balance) = Trap` then
+
....
{status: failed; error: "Query execution trapped"}
....
* Else if `F(Arg, Balance) = Return (Reject (code, msg))` then
+
....
{status: rejected; reject_code: <code>: reject_message: <msg>}
....
* Else if `F(Arg, Balance) = Return (Reply R)` then
+
....
{status: success; result: <R> }
....


[#concrete-canisters]
=== Abstract Canisters to System API

In Section <<abstract-canisters>> we introduced an abstraction over the interface to a canister, to avoid cluttering the abstract specification of the Internet Computer from WebAssembly details. In this section, we will fill the gap and explain how the abstract canister interface maps to the <<system-api,concrete System API>> and the WebAssembly concepts as defined in the https://webassembly.github.io/spec/core/index.html[WebAssembly specification].

==== The concrete `WasmState`

The abstract `WasmState` above models the WebAssembly _store_ `S`, which encompasses the functions, tables, memories and globals of the WebAssembly program, plus additional data maintained by the system, such as the stable memory:
....
WasmState = {
  store : S; // a store as per WebAssembly spec
  self_id : CanId;
  stable_mem : Blob
}
....

As explained in Section “<<system-api-module>>”, the WebAssembly module imports at most _one_ memory and at most _one_ table; in the following, _the_ memory (resp. table) and the fields `mem` and `table` of `S` refer to that. Any system call that accesses the memory (resp. table) will trap if the module does not import the memory (resp. table).

We model `mem` as an array of bytes, and `table` as an array of execution functions.

The abstract `Callback` type above models an entry point for responses:
....
Closure = {
    fun   : i32,
    env   : i32,
}

Callback = {
  on_reply : Closure;
  on_reject : Closure;
}
....

==== The execution state

We can model the execution of WebAssembly functions as stateful functions that have access to the WebAssembly store. In order to also model the behavior of the system imports, which have access to additional data structures, we extend the state as follows:
....
Params = {
  data : NoData | Blob;
  caller : NoCaller | Principal;
  reject_code : 0 | SYS_FATAL | SYS_TRANSIENT | …;
  reject_message : Text;
  time : Timestamp;
  funds_refunded : Funds;
}
ExecutionState = {
  wasm_state : WasmState;
  params : Params;
  response : NoResponse | Response;
  funds_accepted : Funds;
  funds_available : Funds;
  balance : Funds;
  reply_params : { arg : Blob };
  pending_call : MethodCall | NoPendingCall;
  calls : List MethodCall;
}
....

This allows us to model WebAssembly functions, including host-provided imports, as functions with implicit mutable access to an `ExecutionState`, dubbed _execution functions_.
Syntactically, we express this using an implicit argument of type `ref ExecutionState` in angle brackets (e.g. `func<es>(x)` for the invocation of a WebAssembly function with type `+(x : i32) -> ()+`).  The lifetime of the `ExecutionState` data structure is that of one such function invocation.

WARNING: It is nonsensical to pass to an execution function a WebAssembly store `S` that comes from a different WebAssembly module than one defining the function.

==== The concrete `CanisterModule`

Finally we can specify the abstract `CanisterModule` that models a concrete WebAssembly module.

* The `initial_wasm_store` mentioned below is the store of the WebAssembly module after _instantiation_ (as per WebAssembly spec) of the WasmModule contained in the <<canister-module-format,canister module>>, including executing a potential `(start)` function.

* For more convenience when creating a new `ExecutionState`, we define the following partial records:
+
....
empty_params = {
  data = NoData;
  caller = NoCaller;
  reject_code = 0;
  reject_message = "";
  funds_refunded = no_funds;
}

empty_execution_state = {
  wasm_state = (undefined);
  params = (undefined);
  response = NoResponse;
  funds_accepted = no_funds;
  funds_available = no_funds;
  balance = no_funds;
  reply_params = { arg = "" };
  pending_call = NoPendingCall;
  calls = [];
}
....


* The `init` field of the `CanisterModule` is defined as follows:
+
If the WebAssembly module does not export a function called under the name `canister_init`, then the argument blob is ignored and the `initial_wasm_store` is returned:
+
....
init = λ (self_id, arg, balance) →
  Return { store = initial_wasm_store; self_id = self_id; stable_mem = "" }
....
+
Otherwise, if the WebAssembly module exports a function `func` under the name `canister_init`, it is
+
....
init = λ (self_id, arg, balance) →
  let es = ref {empty_execution_state with
      wasm_state = { store = initial_wasm_store; self_id = self_id; stable_mem = "" }
      params = empty_params with { data = arg.data; caller = arg.caller; time = arg.time }
      balance = balance
    }
  try func<es>() with Trap then Trap
  if es.performed_calls ≠ [] then Trap
  if es.response ≠ NoResponse then Trap
  Return es.wasm_state
....
+
This formulation checks afterwards that the system calls `call.perform` or `msg.reply` were not invoked; an implementation can of course trap as soon as these system calls are invoked.

* The `pre_upgrade` field of the `CanisterModule` is defined as follows:
+
If the WebAssembly module does not export a function called under the name `canister_pre_upgrade`, then it simply returns the stable memory:
+
....
pre_upgrade = λ (old_state, caller, time, balance) → Return old_state.stable_mem
....
+
Otherwise, if the WebAssembly module exports a function `func` under the name `canister_pre_upgrade`, it is
+
....
pre_upgrade = λ (old_state, caller, time, balance) →
  let es = ref {empty_execution_state with
      wasm_state = old_state
      params = { empty_params with caller = caller; time = time }
      balance = balance
    }
  try func<es>() with Trap then Trap
  if es.performed_calls ≠ [] then Trap
  if es.response ≠ NoResponse then Trap
  Return es.wasm_state.stable_mem
....


* The `post_upgrade` field of the `CanisterModule` is defined as follows:
+
If the WebAssembly module does not export a function called under the name `canister_post_upgrade`, then the argument blob is ignored and the `initial_wasm_store` is returned:
+
....
post_upgrade = λ (self_id, stable_mem, arg, balance) →
  Return { store = initial_wasm_store; self_id = self_id; stable_mem = stable_mem }
....
+
Otherwise, if the WebAssembly module exports a function `func` under the name `canister_post_upgrade`, it is
+
....
post_upgrade = λ (self_id, stable_mem, arg, balance) →
  let es = ref {empty_execution_state with
      wasm_state = { store = initial_wasm_store; self_id = self_id; stable_mem = stable_mem }
      params = { empty_params with data = arg.data; caller = arg.caller; time = arg.time }
      balance = balance
    }
  try func<es>() with Trap then Trap
  if es.performed_calls ≠ [] then Trap
  if es.response ≠ NoResponse then Trap
  Return es.wasm_state
....

* The partial map `update_methods` of the `CanisterModule` is defined for all method names `method` for which the WebAssembly program exports a function `func` named `canister_update <method>`, and has value
+
....
update_methods[method] = λ (arg, balance, available) → λ wasm_state →
  let es = ref {empty_execution_state with
      wasm_state = wasm_state;
      params = empty_params with {
        data = arg.data;
        caller = arg.caller;
        time = arg.time;
      }
      balance = balance
      funds_available = arg.funds;
    }
  try func<es>() with Trap then Trap
  Return {
    new_state = es.wasm_state;
    new_calls = es.calls;
    response = es.response;
    funds_accepted = es.funds_accepted;
  }
....

* The partial map `query_methods` of the `CanisterModule` is defined for all method names `method` for which the WebAssembly program exports a function `func` named `canister_query <method>`, and has value
+
....
query_methods[method] = λ (arg, balance) → λ wasm_state →
  let es = ref {empty_execution_state with
      wasm_state = wasm_state;
      params = empty_params with {
        data = arg.data;
        caller = arg.caller;
        time = arg.time
      }
      balance = balance
    }
  try func<es>() with Trap then Trap
  if es.funds_accepted ≠ no_funds then Trap
  if es.calls ≠ () then Trap
  if es.response = NoResponse then Trap
  Return es.response;
....
+
This formulation checks afterwards that the system calls `ic0.calls_simple` was not invoked; an implementation can of course trap already when these system calls have been invoked.
+
By construction, the (possibly modified) `es.wasm_state` is discarded.

* The function `callbacks` of the `CanisterModule` is defined  as follows
+
....
callbacks = λ(callbacks, response, refund, time, balance, available) → λ wasm_state →
  let params0 = { empty_params with
    time = time;
    funds_received = refund;
  }
  let (func_id, env, params) = match response with
    Reply data ->
      (callbacks.on_reply.fun, callbacks.on_reply.env,
        { params0 with data})
    Reject (reject_code, reject_message)->
      (callbacks.on_reject.fun, callbacks.on_reject.env,
        { params0 with reject_code; reject_message})

  if fun > |es.wasm_state.store.table| then Trap
  let func = es.wasm_state.store.table[fun]
  if typeof(func) ≠ func (i32) -> () then Trap

  let es = ref {empty_execution_state with
    wasm_state = wasm_state;
    params = params;
    balance = balance;
    funds_available = available;
  }
  func<es>(env)
  Return {
    new_state = es.wasm_state;
    new_calls = es.calls;
    response = es.response;
    balance = es.balance;
  }
....

==== Helper functions

In the following section, we use the these helper functions

....
copy_to_canister<es>(dst : i32, offset : i32, size : i32, data : blob) =
  if offset+size > |data| then Trap
  if dst+size > |es.wasm_state.store.mem| then Trap
  es.wasm_state.store.mem[dst..dst+size] := data[offset..offset+size]

copy_from_canister<es>(src : i32, size : i32) blob =
  if src+size > |es.wasm_state.store.mem| then Trap
  return es.wasm_state.store.mem[src..src+size]
....

==== System imports

Upon _instantiation_ of the WebAssembly module, we can provide the following functions as imports.

....
ic0.msg_arg_data_size<es>() : i32 =
  if es.params.data = NoData then Trap
  return |es.params.arg|

ic0.msg_arg_data_copy<es>(dst:i32, offset:i32, size:i32) =
  if es.params.data = NoData then Trap
  copy_to_canister<es>(dst, offset, size, es.param.arg)

ic0.msg_caller_size() : i32 =
  if es.params.caller = NoCaller then Trap
  return |es.params.caller|

ic0.msg_caller_copy(dst:i32, offset:i32, size:i32) : i32 =
  if es.params.caller = NoCaller then Trap
  copy_to_canister<es>(dst, offset, size, es.params.caller)

ic0.msg_reject_code<es>() : i32 =
  es.params.reject_code

ic0.msg_reject_msg_size<es>() : i32 =
  if es.reject_code = 0 then Trap
  return |es.params.reject_msg|

ic0.msg_reject_msg_copy<es>(dst:i32, offset:i32, size:i32) : i32 =
  if es.reject_code = 0 then Trap
  copy_to_canister<es>(dst, offset, size, es.params.reject_msg)

ic0.msg_reply_data_append<es>(src : i32, size : i32) =
  if es.response ≠ NoResponse then Trap
  es.reply_params.arg := es.reply_params.arg · copy_from_canister<es>(src, size)

ic0.msg_reply<es>() =
  if es.response ≠ NoResponse then Trap
  es.response := Reply (es.reply_params.arg)

ic0.msg_reject<es>(src : i32, size : i32) =
  if es.response ≠ NoResponse then Trap
  es.response := Reject (CANISTER_REJECT, copy_from_canister<es>(src, size))
  es.funds_available := no_funds

ic0.msg_funds_available<es> : ( unit_src : i32, unit_size : i32 ) -> (i64) =
  let unit := copy_from_canister<es>(unit_src, unit_size)
  return es.funds_available(unit)

ic0.msg_funds_refunded<es> : ( unit_src : i32, unit_size : i32 ) -> (i64) =
  return es.params.funds_refunded(unit)

ic0.msg_funds_accept<es> : ( unit_src : i32, unit_size : i32; amount : i64 ) =
  let unit := copy_from_canister<es>(unit_src, unit_size)
  let funds := funds_of_unit(unit, amount)
  if funds > es.funds_available then Trap
  es.funds_available := es.funds_available - funds
  es.funds_accepted := es.funds_accepted + funds


ic0.canister_self_size<es>() : i32 =
  return |es.wasm_state.self_id|

ic0.canister_self_copy<es>(dst:i32, offset:i32, size:i32) =
  copy_to_canister<es>(dst, offset, size, es.wasm_state.self_id)

ic0.canister_balance<es> : ( unit_src : i32, unit_size : i32 ) : i64 =
  let unit := copy_from_canister<es>(unit_src, unit_size)
  return es.balance(unit)

ic0.call_new<es>(
    callee_src  : i32,
    callee_size : i32,
    name_src    : i32,
    name_size   : i32,
    reply_fun   : i32,
    reply_env   : i32,
    reject_fun  : i32,
    reject_env  : i32,
  ) =

  discard_pending_call<es>()

  callee := copy_from_canister<es>(callee_src, callee_size);
  method_name := copy_from_canister<es>(name_src, name_size);

  if reply_fun > |es.wasm_state.store.table| then Trap
  if typeof(es.wasm_state.store.table[reply_fun]) ≠ func (anyref, i32) -> () then Trap

  if reject_fun > |es.wasm_state.store.table| then Trap
  if typeof(es.wasm_state.store.table[reject_fun]) ≠ func (anyref, i32) -> () then Trap

  es.pending_call = MethodCall {
    callee = callee;
    method_name = callee;
    arg = "";
    transferred_funds = no_funds;
    callback = Callback {
      on_reply = Closure { fun = reply_fun; env = reply_env }
      on_reject = Closure { fun = reject_fun; env = reject_env }
    };
  }

ic0.call_data_append<es> (src : i32, size : i32) =
  if es.pending_call = NoPendingCall then Trap
  es.pending_call.arg := es.pending_call.arg · copy_from_canister<es>(src, size)

ic0.call_funds_add<es> (unit_src : i32, unit_size : i32,  amount : i32) =
  if es.pending_call = NoPendingCall then Trap
  let unit := copy_from_canister<es>(unit_src, unit_size)
  let funds := funds_of_unit(unit, amount)
  if funds > es.balance then Trap

  es.balance := es.balance - funds
  es.pending_call.transferred_funds := es.pending_call.transferred_funds + funds

ic0.call_funds_peform<es> () : ( err_code : i32 ) =
  if es.pending_call = NoPendingCall then Trap

  if arbitrary()
  then
    discard_pending_call<es>()
    return 1
  or
    es.calls := es.calls · es.pending_call
    es.pending_call := NoPendingCall
    return 0

// helper function
discard_pending_call<es>() =
  if es.pending_call ≠ NoPendingCall then
    es.balance := es.balance + es.pending_call.transferred_funds
    es.pending_call := NoPendingCall

ic0.stable_size<es>() : (page_count : i32) =
  return |es.wasm_state.stable_mem| / 64k

ic0.stable_grow<es>(new_pages : i32) : (old_page_count : i32) =
  if arbitrary()
  then return -1
  else
    old_size := |es.wasm_state.stable_mem| / 64k
    es.wasm_state.stable_mem :=
      es.wasm_state.stable_mem · repeat(0x00, new_pages * 64k)
    return old_size

ic0.stable_write<es>(offset : i32, src : i32, size : i32)
  if src+size > |es.wasm_state.store.mem| then Trap
  if offset+size > |es.wasm_state.stable_mem| then Trap

  es.wasm_state.stable_mem[offset..offset+size] := es.wasm_state.store.mem[src..src+size]

ic0.stable_read<es>(dst : i32, offset : i32, size : i32)
  if offset+size > |es.wasm_state.stable_mem| then Trap
  if dst+size > |es.wasm_state.store.mem| then Trap

  es.wasm_state.store.mem[offset..offset+size] := es.wasm_state.stable.mem[src..src+size]

ic0.time<es>() : i32 =
  return es.params.time

ic0.debug_print<es>(src : i32, size : i32) =
  return

ic0.trap<es>(src : i32, size : i32) =
  Trap
....



include::changelog.adoc[]
